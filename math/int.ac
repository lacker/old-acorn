import nat_gcd
import nat
type Nat: nat.Nat
type Int: axiom

let from_nat: Nat -> Int = axiom
let negate: Int -> Int = axiom
let abs: Int -> Nat = axiom

let 0: Int = from_nat(nat.0)
let 1: Int = from_nat(nat.1)

axiom neg_zero: negate(0) = 0

axiom neg_neg(a: Int): negate(negate(a)) = a

axiom abs_neg(a: Int): abs(negate(a)) = abs(a)

axiom abs_from_nat(n: Nat): abs(from_nat(n)) = n

axiom neg_or_pos(a: Int): a = from_nat(abs(a)) | a = negate(from_nat(abs(a)))

axiom fix_neg(a: Int): negate(a) = a -> a = 0

theorem from_eq_neg_from(p: Nat, q: Nat): from_nat(p) = negate(from_nat(q)) -> p = nat.0 & q = nat.0 by {
    abs(from_nat(p)) = abs(negate(from_nat(q)))
    abs(from_nat(p)) = abs(from_nat(q))
    p = q
    from_nat(p) = negate(from_nat(p))
    from_nat(p) = 0
}

theorem abs_zero: abs(0) = nat.0

theorem one_neq_zero: 1 != 0 by {
    abs(from_nat(nat.1)) != nat.0
}

// Subtraction that goes from naturals into integers.
// We will use this as the primary representation for proving things about integers, so we prove
// as many useful things about sub_nat as we can, before defining more stuff.
define sub_nat(m: Nat, n: Nat) -> Int: if nat.lte(n, m) {
    from_nat(nat.sub(m, n))
    } else {
    negate(from_nat(nat.sub(n, m)))
}

theorem sub_nat_zero_right(n: Nat): sub_nat(n, nat.0) = from_nat(n)

theorem sub_nat_zero_left(n: Nat): sub_nat(nat.0, n) = negate(from_nat(n)) by {
    if n = nat.0 {
        sub_nat(nat.0, n) = 0
        sub_nat(nat.0, n) = negate(0)
        sub_nat(nat.0, n) = negate(from_nat(n))
    } else {
        sub_nat(nat.0, n) = negate(from_nat(n))
    }
}

theorem sub_nat_self(n: Nat): sub_nat(n, n) = 0

theorem sub_nat_add_left(p: Nat, q: Nat): sub_nat(nat.add(p, q), q) = from_nat(p)

theorem neg_sub_nat(m: Nat, n: Nat): sub_nat(m, n) = negate(sub_nat(n, m)) by {
    if m = n {
        sub_nat(m, n) = 0
        sub_nat(m, n) = negate(0)
        sub_nat(m, n) = negate(sub_nat(n, m))
    } else {
        if nat.lte(n, m) {
            !nat.lte(m, n)
            sub_nat(m, n) = negate(sub_nat(n, m))
        } else {
            sub_nat(m, n) = negate(sub_nat(n, m))
        }
    }
}

theorem sub_nat_add_right(p: Nat, q: Nat): sub_nat(p, nat.add(p, q)) = negate(from_nat(q))

// Half of a "without loss of generality" argument
theorem sub_nat_eq_helper(m: Nat, n: Nat, p: Nat, q: Nat):
    nat.add(m, n) = nat.add(p, q) & nat.lte(p, m) -> sub_nat(m, p) = sub_nat(q, n) by {
    exists(d: Nat) { nat.add(p, d) = m }
    sub_nat(m, p) = from_nat(d)
    nat.add(m, n) = nat.add(nat.add(p, d), n)
    nat.add(p, q) = nat.add(nat.add(p, d), n)
    nat.add(p, q) = nat.add(p, nat.add(d, n))
    q = nat.add(d, n)
    sub_nat(q, n) = from_nat(d)
    sub_nat(m, p) = sub_nat(q, n)
}

theorem sub_nat_eq(m: Nat, n: Nat, p: Nat, q: Nat): nat.add(m, n) = nat.add(p, q) -> sub_nat(m, p) = sub_nat(q, n) by {
    if nat.lte(p, m) {
        sub_nat(m, p) = sub_nat(q, n)
    } else {
        nat.lte(m, p)
        sub_nat(m, p) = sub_nat(q, n)
    }
}

theorem sub_nat_imp_add(i: Nat, j: Nat, k: Nat): sub_nat(i, j) = from_nat(k) -> nat.add(j, k) = i by {
    if nat.lte(j, i) {
        exists(d: Nat) { nat.add(j, d) = i }
        sub_nat(i, j) = from_nat(d)
        d = k
        nat.add(j, k) = i
    } else {
        exists(d: Nat) { nat.add(i, d) = j }
        sub_nat(i, j) = negate(from_nat(d))
        from_nat(k) = negate(from_nat(d))
        k = nat.0
        d = nat.0
        i = j
        false
    }
}

theorem sub_nat_negate_imp_add(i: Nat, j: Nat, k: Nat): sub_nat(i, j) = negate(from_nat(k)) -> nat.add(i, k) = j by {
    if nat.lte(j, i) {
        exists(d: Nat) { nat.add(j, d) = i }
        sub_nat(i, j) = from_nat(d)
        from_nat(d) = negate(from_nat(k))
        d = nat.0
        k = nat.0
        i = j
        nat.add(i, k) = j
    } else {
        nat.lte(i, j)
        exists(d: Nat) { nat.add(i, d) = j }
        sub_nat(j, i) = from_nat(d)
        sub_nat(i, j) = negate(from_nat(d))
        abs(sub_nat(j, i)) = d
        abs(negate(sub_nat(i, j))) = d
        abs(from_nat(k)) = d
        k = d
        nat.add(i, k) = j
    }
}

theorem sub_nat_cancel_right(i: Nat, j: Nat, k: Nat): sub_nat(i, k) = sub_nat(j, k) -> i = j by {
    if nat.lte(k, i) {
        exists(d: Nat) { nat.add(k, d) = i }
        sub_nat(i, k) = from_nat(d)
        sub_nat(j, k) = from_nat(d)
        nat.add(k, d) = j
        i = j
    } else {
        nat.lte(i, k)
        exists(d: Nat) { nat.add(i, d) = k }
        sub_nat(k, i) = from_nat(d)
        sub_nat(i, k) = negate(from_nat(d))
        sub_nat(j, k) = negate(from_nat(d))
        sub_nat(k, j) = from_nat(d)
        nat.add(j, d) = k
        i = j
    }
}

theorem sub_nat_cancel_left(i: Nat, j: Nat, k: Nat): sub_nat(k, i) = sub_nat(k, j) -> i = j by {
    sub_nat(i, k) = sub_nat(j, k)
}

theorem sub_nat_add_cancel_right(m: Nat, n: Nat, k: Nat): sub_nat(m, n) = sub_nat(nat.add(m, k), nat.add(n, k)) by {
    nat.add(m, nat.add(n, k)) = nat.add(n, nat.add(m, k))
}

theorem sub_nat_add_cancel_left(m: Nat, n: Nat, k: Nat): sub_nat(m, n) = sub_nat(nat.add(k, m), nat.add(k, n))

// Half of a "without loss of generality" argument
theorem sub_nat_imp_add_eq_helper(m: Nat, n: Nat, p: Nat, q: Nat):
    sub_nat(m, p) = sub_nat(q, n) & nat.lte(p, m) -> nat.add(m, n) = nat.add(p, q) by {
    exists(d: Nat) { nat.add(p, d) = m }
    sub_nat(m, p) = from_nat(d)
    sub_nat(q, n) = from_nat(d)
    nat.add(n, d) = q
    nat.add(nat.add(m, n), d) = nat.add(nat.add(p, q), d)
}

theorem sub_nat_imp_add_eq(m: Nat, n: Nat, p: Nat, q: Nat): sub_nat(m, p) = sub_nat(q, n) -> nat.add(m, n) = nat.add(p, q) by {
    if nat.lte(p, m) {
        nat.add(m, n) = nat.add(p, q)
    } else {
        nat.lte(m, p)
        nat.add(m, n) = nat.add(p, q)
    }
}

theorem sub_nat_double_cancel_left(p: Nat, q: Nat, r: Nat, s: Nat, t: Nat):
    sub_nat(nat.add(p, t), q) = sub_nat(nat.add(r, t), s) -> sub_nat(p, q) = sub_nat(r, s) by {
    nat.add(nat.add(p, t), s) = nat.add(q, nat.add(r, t))
    nat.add(nat.add(p, s), t) = nat.add(nat.add(q, r), t)
    nat.add(p, s) = nat.add(q, r)
}

theorem sub_nat_double_cancel_right(p: Nat, q: Nat, r: Nat, s: Nat, t: Nat):
    sub_nat(p, nat.add(q, t)) = sub_nat(r, nat.add(s, t)) -> sub_nat(p, q) = sub_nat(r, s) by {
    nat.add(p, nat.add(s, t)) = nat.add(nat.add(q, t), r)
    nat.add(nat.add(p, s), t) = nat.add(nat.add(q, r), t)
    nat.add(p, s) = nat.add(q, r)
}

// Now that we've proven a bunch of stuff about sub_nat, we define the positive and negative parts so that we can
// represent each integer as a sub_nat, and start defining useful functions on integers.

define is_negative(a: Int) -> Bool: a != from_nat(abs(a))

theorem zero_not_neg: !is_negative(0)

define is_positive(a: Int) -> Bool: is_negative(negate(a))

theorem zero_not_pos: !is_positive(0) by {
    negate(0) = 0
    !is_negative(0)
    !is_negative(negate(0))
}

theorem one_pos: is_positive(1) by {
    is_negative(negate(from_nat(nat.1)))
    is_negative(negate(1))
}

theorem nonzero_pos_or_neg(a: Int): a != 0 -> is_positive(a) | is_negative(a) by {
    if !is_positive(a) {
        is_negative(a)
    }
}

theorem pos_is_not_neg(a: Int): is_positive(a) -> !is_negative(a) by {
    negate(from_nat(abs(negate(a)))) = negate(a)
    negate(from_nat(abs(negate(negate(a))))) = negate(a)
}

theorem non_pos_is_neg_abs(a: Int): !is_positive(a) -> a = negate(from_nat(abs(a))) by {
    from_nat(abs(a)) = negate(a)
}

define pos_part(a: Int) -> Nat: if is_positive(a) {
    abs(a)
} else {
    nat.0
}

define neg_part(a: Int) -> Nat: if is_positive(a) {
    nat.0
} else {
    abs(a)
}

theorem sub_nat_parts(a: Int): sub_nat(pos_part(a), neg_part(a)) = a by {
    if is_positive(a) {
        sub_nat(abs(a), nat.0) = a
        sub_nat(pos_part(a), neg_part(a)) = a
    } else {
        sub_nat(nat.0, abs(a)) = a
        sub_nat(pos_part(a), neg_part(a)) = a
    }
}

theorem pos_part_neg(a: Int): pos_part(negate(a)) = neg_part(a) by {
    if is_positive(a) {
        neg_part(a) = nat.0
        !is_positive(negate(a))
        pos_part(negate(a)) = nat.0
        pos_part(negate(a)) = neg_part(a)
    } else {
        neg_part(a) = abs(a)
        !is_negative(negate(a))
        pos_part(negate(a)) = abs(negate(a))
        pos_part(negate(a)) = abs(a)
        pos_part(negate(a)) = neg_part(a)
    }
}

theorem pos_part_from(n: Nat): pos_part(from_nat(n)) = n by {
    if n = nat.0 {
        pos_part(from_nat(n)) = n
    } else {
        pos_part(from_nat(n)) = abs(from_nat(n))
        pos_part(from_nat(n)) = n
    }
}

theorem neg_part_from(n: Nat): neg_part(from_nat(n)) = nat.0

theorem neg_part_neg(a: Int): neg_part(negate(a)) = pos_part(a)

theorem parts_sub_nat(j: Nat, k: Nat): nat.add(pos_part(sub_nat(j, k)), k) = nat.add(neg_part(sub_nat(j, k)), j)

theorem add_part_sub_nat(r: Nat, s: Nat): nat.add(r, neg_part(sub_nat(r, s))) = nat.add(s, pos_part(sub_nat(r, s)))

// Addition, and theorems about addition

class Int {
    define add(self: Int, other: Int) -> Int: sub_nat(nat.add(pos_part(self), pos_part(other)),
                                                      nat.add(neg_part(self), neg_part(other)))
}

theorem add_zero_left(a: Int): (0 + a) = a by {
    pos_part(0) = nat.0
    neg_part(0) = nat.0
    nat.add(pos_part(0), pos_part(a)) = pos_part(a)
    nat.add(neg_part(0), neg_part(a)) = neg_part(a)
    (0 + a) = sub_nat(pos_part(a), neg_part(a))
}

theorem add_zero_right(a: Int): a + 0 = a by {
    pos_part(0) = nat.0
    neg_part(0) = nat.0
    nat.add(pos_part(a), pos_part(0)) = pos_part(a)
    nat.add(neg_part(a), neg_part(0)) = neg_part(a)
    a + 0 = sub_nat(pos_part(a), neg_part(a))
}

theorem add_comm(a: Int, b: Int): a + b = b + a by {
    a + b = sub_nat(nat.add(pos_part(b), pos_part(a)), nat.add(neg_part(a), neg_part(b)))
}

theorem neg_distrib(a: Int, b: Int): negate(a + b) = negate(a) + negate(b) by {
    nat.add(pos_part(negate(a)), pos_part(negate(b))) = nat.add(neg_part(a), neg_part(b))
    nat.add(neg_part(negate(a)), neg_part(negate(b))) = nat.add(pos_part(a), pos_part(b))
    negate(a) + negate(b) = sub_nat(nat.add(pos_part(negate(a)), pos_part(negate(b))),
                                            nat.add(neg_part(negate(a)), neg_part(negate(b))))
    negate(a) + negate(b) = sub_nat(nat.add(neg_part(a), neg_part(b)),
                                            nat.add(neg_part(negate(a)), neg_part(negate(b))))                                        
    negate(a) + negate(b) = sub_nat(nat.add(neg_part(a), neg_part(b)),
                                            nat.add(pos_part(a), pos_part(b)))
    negate(a) + negate(b) = negate(sub_nat(nat.add(pos_part(a), pos_part(b)), nat.add(neg_part(a), neg_part(b))))
}

theorem parts_of_add(a: Int, b: Int):
    (nat.add(nat.add(pos_part(a), pos_part(b)), neg_part(a + b)) =
     nat.add(nat.add(neg_part(a), neg_part(b)), pos_part(a + b))) by {
    a + b = sub_nat(nat.add(pos_part(a), pos_part(b)), nat.add(neg_part(a), neg_part(b)))
    let j: Nat = nat.add(pos_part(a), pos_part(b))
    let k: Nat = nat.add(neg_part(a), neg_part(b))
    a + b = sub_nat(j, k)
    nat.add(nat.add(pos_part(a), pos_part(b)), neg_part(a + b)) = nat.add(j, neg_part(sub_nat(j, k)))
    nat.add(nat.add(neg_part(a), neg_part(b)), pos_part(a + b)) = nat.add(k, pos_part(sub_nat(j, k)))
    nat.add(pos_part(sub_nat(j, k)), k) = nat.add(neg_part(sub_nat(j, k)), j)
    nat.add(nat.add(pos_part(a), pos_part(b)), neg_part(a + b)) = nat.add(pos_part(sub_nat(j, k)), k)
    nat.add(nat.add(neg_part(a), neg_part(b)), pos_part(a + b)) = nat.add(neg_part(sub_nat(j, k)), j)
    nat.add(nat.add(pos_part(a), pos_part(b)), neg_part(a + b)) = nat.add(neg_part(sub_nat(j, k)), j)
}

theorem add_neg(a: Int): a + negate(a) = 0 by {
    a + negate(a) = sub_nat(nat.add(pos_part(a), pos_part(negate(a))), nat.add(neg_part(a), neg_part(negate(a))))
    a + negate(a) = sub_nat(nat.add(pos_part(a), neg_part(a)), nat.add(neg_part(a), pos_part(a)))
    a + negate(a) = 0
}

theorem add_eq_zero(a: Int, b: Int): a + b = 0 -> a = negate(b) by {
    sub_nat(nat.add(pos_part(a), pos_part(b)), nat.add(neg_part(a), neg_part(b))) = 0
    nat.add(nat.add(neg_part(a), neg_part(b)), nat.0) = nat.add(pos_part(a), pos_part(b))
    nat.add(pos_part(a), pos_part(b)) = nat.add(neg_part(a), neg_part(b))
    nat.add(pos_part(a), neg_part(negate(b))) = nat.add(neg_part(a), pos_part(negate(b)))
    sub_nat(pos_part(a), neg_part(a)) = sub_nat(pos_part(negate(b)), neg_part(negate(b)))
    a = negate(b)    
}

theorem add_right_cancel(a: Int, b: Int, c: Int): a + c = b + c -> a = b by {
    (sub_nat(nat.add(pos_part(a), pos_part(c)), nat.add(neg_part(a), neg_part(c))) =
     sub_nat(nat.add(pos_part(b), pos_part(c)), nat.add(neg_part(b), neg_part(c))))
    sub_nat(pos_part(a), nat.add(neg_part(a), neg_part(c))) = sub_nat(pos_part(b), nat.add(neg_part(b), neg_part(c)))
    sub_nat(pos_part(a), neg_part(a)) = sub_nat(pos_part(b), neg_part(b))
}

theorem add_left_cancel(a: Int, b: Int, c: Int): c + a = c + b -> a = b by {
    a + c = b + c
}

theorem add_sub_nat_left_pos(p: Nat, q: Nat, r: Nat): (sub_nat(p, q) + from_nat(r)) = sub_nat(nat.add(p, r), q) by {
    (sub_nat(p, q) + from_nat(r)) = sub_nat(nat.add(pos_part(sub_nat(p, q)), pos_part(from_nat(r))),
                                              nat.add(neg_part(sub_nat(p, q)), neg_part(from_nat(r))))
    (sub_nat(p, q) + from_nat(r)) = sub_nat(nat.add(pos_part(sub_nat(p, q)), r),
                                              nat.add(neg_part(sub_nat(p, q)), neg_part(from_nat(r))))
    (sub_nat(p, q) + from_nat(r)) = sub_nat(nat.add(pos_part(sub_nat(p, q)), r),
                                              nat.add(neg_part(sub_nat(p, q)), nat.0))
    (sub_nat(p, q) + from_nat(r)) = sub_nat(nat.add(pos_part(sub_nat(p, q)), r),
                                              neg_part(sub_nat(p, q))) 
    nat.add(nat.add(p, r), neg_part(sub_nat(p, q))) = nat.add(q, nat.add(pos_part(sub_nat(p, q)), r))
    sub_nat(nat.add(p, r), q) = sub_nat(nat.add(pos_part(sub_nat(p, q)), r), neg_part(sub_nat(p, q)))
}

theorem add_sub_nat_left_neg(p: Nat, q: Nat, r: Nat): (sub_nat(p, q) + negate(from_nat(r))) = sub_nat(p, nat.add(q, r)) by {
    (sub_nat(p, q) + negate(from_nat(r))) = negate(negate(sub_nat(p, q)) + from_nat(r))
    (sub_nat(p, q) + negate(from_nat(r))) = negate(sub_nat(q, p) + from_nat(r))
    (sub_nat(p, q) + negate(from_nat(r))) = negate(sub_nat(nat.add(q, r), p))
}

theorem add_sub_nat_left(p: Nat, q: Nat, a: Int):
    (sub_nat(p, q) + a) = sub_nat(nat.add(p, pos_part(a)), nat.add(q, neg_part(a))) by {
    if is_positive(a) {
        (sub_nat(p, q) + a) = (sub_nat(p, q) + from_nat(abs(a)))
        (sub_nat(p, q) + a) = sub_nat(nat.add(p, abs(a)), q)
        (sub_nat(p, q) + a) = sub_nat(nat.add(p, pos_part(a)), q)
        (sub_nat(p, q) + a) = sub_nat(nat.add(p, pos_part(a)), nat.add(q, neg_part(a)))
    } else {
        (sub_nat(p, q) + a) = (sub_nat(p, q) + negate(from_nat(abs(a))))
        (sub_nat(p, q) + a) = sub_nat(p, nat.add(q, abs(a)))
        (sub_nat(p, q) + a) = sub_nat(p, nat.add(q, neg_part(a)))
        (sub_nat(p, q) + a) = sub_nat(nat.add(p, pos_part(a)), nat.add(q, neg_part(a)))
    }
}

theorem add_sub_nat_right(p: Nat, q: Nat, a: Int):
    a + sub_nat(p, q) = sub_nat(nat.add(pos_part(a), p), nat.add(neg_part(a), q)) by {
    a + sub_nat(p, q) = (sub_nat(p, q) + a)
    a + sub_nat(p, q) = sub_nat(nat.add(p, pos_part(a)), nat.add(q, neg_part(a)))
    a + sub_nat(p, q) = sub_nat(nat.add(pos_part(a), p), nat.add(q, neg_part(a)))
}

theorem add_sub_nat(p: Nat, q: Nat, r: Nat, s: Nat):
    (sub_nat(p, q) + sub_nat(r, s)) = sub_nat(nat.add(p, r), nat.add(q, s)) by {
    (sub_nat(p, q) + sub_nat(r, s)) = sub_nat(nat.add(p, pos_part(sub_nat(r, s))),
                                                nat.add(q, neg_part(sub_nat(r, s))))
    nat.add(nat.add(p, q), nat.add(r, neg_part(sub_nat(r, s)))) = nat.add(nat.add(p, q), nat.add(s, pos_part(sub_nat(r, s))))
    nat.add(p, nat.add(q, nat.add(r, neg_part(sub_nat(r, s))))) = nat.add(nat.add(p, q), nat.add(s, pos_part(sub_nat(r, s))))
    nat.add(p, nat.add(nat.add(q, r), neg_part(sub_nat(r, s)))) = nat.add(nat.add(p, q), nat.add(s, pos_part(sub_nat(r, s))))
    nat.add(p, nat.add(nat.add(r, q), neg_part(sub_nat(r, s)))) = nat.add(nat.add(p, q), nat.add(s, pos_part(sub_nat(r, s))))
    nat.add(p, nat.add(r, nat.add(q, neg_part(sub_nat(r, s))))) = nat.add(nat.add(p, q), nat.add(s, pos_part(sub_nat(r, s))))
    nat.add(nat.add(p, r), nat.add(q, neg_part(sub_nat(r, s)))) = nat.add(nat.add(p, q), nat.add(s, pos_part(sub_nat(r, s))))
    nat.add(nat.add(p, r), nat.add(q, neg_part(sub_nat(r, s)))) = nat.add(nat.add(q, p), nat.add(s, pos_part(sub_nat(r, s))))
    nat.add(nat.add(p, r), nat.add(q, neg_part(sub_nat(r, s)))) = nat.add(q, nat.add(p, nat.add(s, pos_part(sub_nat(r, s)))))
    nat.add(nat.add(p, r), nat.add(q, neg_part(sub_nat(r, s)))) = nat.add(q, nat.add(nat.add(p, s), pos_part(sub_nat(r, s))))
    nat.add(nat.add(p, r), nat.add(q, neg_part(sub_nat(r, s)))) = nat.add(q, nat.add(nat.add(s, p), pos_part(sub_nat(r, s))))
    nat.add(nat.add(p, r), nat.add(q, neg_part(sub_nat(r, s)))) = nat.add(q, nat.add(s, nat.add(p, pos_part(sub_nat(r, s)))))
    nat.add(nat.add(p, r), nat.add(q, neg_part(sub_nat(r, s)))) = nat.add(nat.add(q, s), nat.add(p, pos_part(sub_nat(r, s))))
    sub_nat(nat.add(p, r), nat.add(q, s)) = sub_nat(nat.add(p, pos_part(sub_nat(r, s))),
                                                    nat.add(q, neg_part(sub_nat(r, s))))
}

theorem add_sub_nat_3_left(p: Nat, q: Nat, r: Nat, s: Nat, t: Nat, u: Nat):
    sub_nat(p, q) + sub_nat(r, s) + sub_nat(t, u) = sub_nat(nat.add(nat.add(p, r), t), nat.add(nat.add(q, s), u)) by {
    let lhs: Int = sub_nat(p, q) + sub_nat(r, s) + sub_nat(t, u)
    lhs = sub_nat(nat.add(p, r), nat.add(q, s)) + sub_nat(t, u)
    lhs = sub_nat(nat.add(nat.add(p, r), t), nat.add(nat.add(q, s), u))
}

theorem add_sub_nat_3_right(p: Nat, q: Nat, r: Nat, s: Nat, t: Nat, u: Nat):
    sub_nat(p, q) + (sub_nat(r, s) + sub_nat(t, u)) = sub_nat(nat.add(p, nat.add(r, t)), nat.add(q, nat.add(s, u))) by {
    let lhs: Int = sub_nat(p, q) + (sub_nat(r, s) + sub_nat(t, u))
    lhs = (sub_nat(p, q) + sub_nat(nat.add(r, t), nat.add(s, u)))
    lhs = sub_nat(nat.add(p, nat.add(r, t)), nat.add(q, nat.add(s, u)))
}

theorem add_sub_nat_assoc(p: Nat, q: Nat, r: Nat, s: Nat, t: Nat, u: Nat):
    sub_nat(p, q) + sub_nat(r, s) + sub_nat(t, u) = sub_nat(p, q) + (sub_nat(r, s) + sub_nat(t, u)) by {
    let lhs: Int = sub_nat(p, q) + sub_nat(r, s) + sub_nat(t, u)
    lhs = sub_nat(nat.add(nat.add(p, r), t), nat.add(nat.add(q, s), u))
    lhs = sub_nat(nat.add(p, nat.add(r, t)), nat.add(nat.add(q, s), u))
    lhs = sub_nat(nat.add(p, nat.add(r, t)), nat.add(q, nat.add(s, u)))
    lhs = sub_nat(p, q) + (sub_nat(r, s) + sub_nat(t, u))
}

theorem add_assoc(a: Int, b: Int, c: Int): a + (b + c) = a + b + (c) by {
    add_sub_nat_assoc(pos_part(a), neg_part(a), pos_part(b), neg_part(b), pos_part(c), neg_part(c))
}

theorem add_from_nat(a: Nat, b: Nat): from_nat(a) + from_nat(b) = from_nat(nat.add(a, b))

theorem add_pos_nonneg(a: Int, b: Int): is_positive(a) & !is_negative(b) -> is_positive(a + b) by {
    if b = 0 {
        a + b = a
        is_positive(a + b)
    } else {
        is_positive(b)
        a = from_nat(abs(a))
        b = from_nat(abs(b))
        a + b = from_nat(nat.add(abs(a), abs(b)))
        nat.add(abs(a), abs(b)) != nat.0
        is_positive(from_nat(nat.add(abs(a), abs(b))))
        is_positive(a + b)
    }
}

theorem add_neg_nonpos(a: Int, b: Int): is_negative(a) & !is_positive(b) -> is_negative(a + b) by {
    is_positive(negate(a))
    !is_negative(negate(b))
    is_positive(negate(a) + negate(b))
    is_positive(negate(a + b))
}

theorem add_nonneg_nonneg(a: Int, b: Int): !is_negative(a) & !is_negative(b) -> !is_negative(a + b)

theorem add_nonpos_nonpos(a: Int, b: Int): !is_positive(a) & !is_positive(b) -> !is_positive(a + b)

theorem add_comm_4(a: Int, b: Int, c: Int, d: Int): (a + b) + (c + d) = (a + c) + (b + d) by {
    a + (b + c) = a + c + b
}

// Subtraction, and theorems about subtraction

class Int {
    define sub(self: Int, other: Int) -> Int: self + negate(other)
}

theorem sub_zero_right(a: Int): a - 0 = a by {
    a - 0 = a + negate(0)
    a - 0 = a + 0
    a - 0 = a
}

theorem sub_zero_left(a: Int): 0 - a = negate(a) by {
    0 - a = 0 + negate(a)
    0 - a = negate(a)
}

theorem sub_anticomm(a: Int, b: Int): a - b = negate(b - a) by {
    negate(b - a) = negate(b + negate(a))
    negate(b - a) = negate(b) + negate(negate(a))
    negate(b - a) = negate(b) + a
    negate(b - a) = a + negate(b)
}

theorem sub_self(a: Int): a - a = 0

theorem sub_eq_zero(a: Int, b: Int): a - b = 0 -> a = b

theorem sub_add_left(a: Int, b: Int): (a + b) - b = a

theorem neg_sub(a: Int, b: Int): negate(a - b) = b - a

theorem sub_add_right(a: Int, b: Int): a - (a + b) = negate(b)

theorem sub_imp_add(a: Int, b: Int, c: Int): a - b = c -> b + c = a

theorem sub_negate_imp_add(a: Int, b: Int, c: Int): a - b = negate(c) -> a + c = b

theorem sub_cancel_right(a: Int, b: Int, c: Int): a - c = b - c -> a = b

theorem sub_cancel_left(a: Int, b: Int, c: Int): a - b = a - c -> b = c

theorem sub_add_cancel_left(a: Int, b: Int, c: Int): (a + b) - (a + c) = b - c by {
    b + a + negate(a + c) = b - c
    a + b + negate(a + c) = b - c
}

theorem sub_add_cancel_right(a: Int, b: Int, c: Int): (a + c) - (b + c) = a - b

// Integer-natural multiplication

define mul_nat(a: Int, n: Nat) -> Int: if is_negative(a) {
    negate(from_nat(nat.mul(abs(a), n)))
} else {
    from_nat(nat.mul(abs(a), n))
}

theorem mul_nat_zero_right(a: Int): mul_nat(a, nat.0) = 0 by {
    if is_negative(a) {
        mul_nat(a, nat.0) = 0
    } else {
        mul_nat(a, nat.0) = 0
    }
}

theorem mul_nat_zero_left(n: Nat): mul_nat(0, n) = 0 by {
    !is_positive(0)
    from_nat(nat.mul(nat.0, n)) = 0
}

theorem mul_nat_nonpos_left(a: Int, n: Nat):
    !is_positive(a) -> mul_nat(a, n) = negate(from_nat(nat.mul(abs(a), n))) by {
    if a = 0 {
        mul_nat(a, n) = negate(from_nat(nat.mul(abs(a), n)))
    } else {
        mul_nat(a, n) = negate(from_nat(nat.mul(abs(a), n)))
    }
}

theorem mul_nat_negate_left(a: Int, n: Nat): mul_nat(negate(a), n) = negate(mul_nat(a, n)) by {
    if is_positive(a) {
        is_negative(negate(a))
        mul_nat(negate(a), n) = negate(from_nat(nat.mul(abs(negate(a)), n)))
        mul_nat(negate(a), n) = negate(from_nat(nat.mul(abs(a), n)))
        mul_nat(negate(a), n) = negate(mul_nat(a, n))
    } else {
        !is_negative(negate(a))
        mul_nat(negate(a), n) = negate(mul_nat(a, n))
    }
}

theorem mul_nat_nonneg_suc(a: Int, n: Nat): !is_negative(a) -> mul_nat(a, nat.suc(n)) = mul_nat(a, n) + a by {
    mul_nat(a, nat.suc(n)) = from_nat(nat.mul(abs(a), nat.suc(n)))
    mul_nat(a, nat.suc(n)) = from_nat(nat.add(nat.mul(abs(a), n), abs(a)))
    mul_nat(a, nat.suc(n)) = from_nat(nat.mul(abs(a), n)) +  from_nat(abs(a))
    mul_nat(a, nat.suc(n)) = mul_nat(a, n) +  a
}

theorem mul_nat_suc(a: Int, n: Nat): mul_nat(a, nat.suc(n)) = (mul_nat(a, n) + a) by {
    if is_negative(a) {
        is_positive(negate(a))
        mul_nat(a, nat.suc(n)) = negate(mul_nat(negate(a), nat.suc(n)))
        mul_nat(a, nat.suc(n)) = negate(mul_nat(negate(a), n) + negate(a))
        mul_nat(a, nat.suc(n)) = negate(negate(mul_nat(a, n)) + negate(a))
        mul_nat(a, nat.suc(n)) = negate(negate((mul_nat(a, n) + a)))
        mul_nat(a, nat.suc(n)) = (mul_nat(a, n) + a)
    } else {
        mul_nat(a, nat.suc(n)) = (mul_nat(a, n) + a)
    }
}

theorem mul_nat_distrib_right(a: Int, b: Int, n: Nat): mul_nat(a + b, n) = (mul_nat(a, n) + mul_nat(b, n)) by {
    define f(x: Nat) -> Bool: mul_nat_distrib_right(a, b, x)
    nat.induction(f)

    // Prove the base case
    mul_nat(a + b, nat.0) = 0
    mul_nat(a, nat.0) = 0
    mul_nat(b, nat.0) = 0
    mul_nat(a, nat.0) + mul_nat(b, nat.0) = 0
    mul_nat(a + b, nat.0) = mul_nat(a, nat.0) + mul_nat(b, nat.0)
    f(nat.0)

    // Induct
    forall(x: Nat) {
        if f(x) {
            mul_nat(a + b, x) = mul_nat(a, x) + mul_nat(b, x)
            mul_nat(a + b, nat.suc(x)) = (mul_nat(a, x) + a) + (mul_nat(b, x) + b)
            mul_nat(a + b, nat.suc(x)) = mul_nat(a, nat.suc(x)) + (mul_nat(b, x) + b)
            mul_nat(a + b, nat.suc(x)) = mul_nat(a, nat.suc(x)) + mul_nat(b, nat.suc(x))
            f(nat.suc(x))
        }
    }
}

theorem mul_nat_from_nat_left(a: Nat, b: Nat): mul_nat(from_nat(a), b) = from_nat(nat.mul(a, b)) by {
    if a = nat.0 {
        mul_nat(from_nat(a), b) = from_nat(nat.mul(a, b))
    } else {
        mul_nat(from_nat(a), b) = from_nat(nat.mul(a, b))
    }
}

// Integer-integer multiplication

class Int {
    define mul(self: Int, n: Int) -> Int: if is_positive(n) {
        mul_nat(self, abs(n))
    } else {
        negate(mul_nat(self, abs(n)))
    }
}

theorem mul_zero_right(a: Int): a * 0 = 0 by {
    !is_positive(0)
    a * 0 = negate(mul_nat(a, nat.0))
    a * 0 = negate(0)
}

theorem mul_nat_from_nat_right(a: Int, n: Nat): mul_nat(a, n) = (a * from_nat(n)) by {
    if n = nat.0 {
        a * from_nat(n) = mul_nat(a, abs(from_nat(n)))
    } else {
        a * from_nat(n) = mul_nat(a, abs(from_nat(n)))
    }
}

theorem mul_nonneg_right(a: Int, b: Int): !is_negative(b) -> a * b = mul_nat(a, abs(b)) by {
    if b = 0 {
        a * b = 0
        mul_nat(a, abs(b)) = 0
        a * b = mul_nat(a, abs(b))
    } else {
        a * b = mul_nat(a, abs(b))
    }
}

theorem mul_nonneg_nonneg(a: Int, b: Int):
    !is_negative(a) & !is_negative(b) -> a * b = from_nat(nat.mul(abs(a), abs(b))) by {
    a * b = mul_nat(a, abs(b))
}

theorem mul_nonneg_nonpos(a: Int, b: Int):
    !is_negative(a) & !is_positive(b) -> a * b = negate(from_nat(nat.mul(abs(a), abs(b)))) by {
    a * b = negate(mul_nat(a, abs(b)))
}

theorem mul_nonpos_nonneg(a: Int, b: Int):
    !is_positive(a) & !is_negative(b) -> a * b = negate(from_nat(nat.mul(abs(a), abs(b)))) by {
    a * b = mul_nat(a, abs(b))
}

theorem mul_nonpos_nonpos(a: Int, b: Int):
    !is_positive(a) & !is_positive(b) -> a * b = from_nat(nat.mul(abs(a), abs(b))) by {
    a * b = negate(mul_nat(a, abs(b)))
    a * b = negate(negate(from_nat(nat.mul(abs(a), abs(b)))))
}

theorem mul_nonneg_nonneg_nonneg(a: Int, b: Int): !is_negative(a) & !is_negative(b) -> !is_negative(a * b) by {
    a * b = from_nat(nat.mul(abs(a), abs(b)))
    !is_negative(from_nat(nat.mul(abs(a), abs(b))))
}

theorem mul_nonneg_nonpos_nonpos(a: Int, b: Int): !is_negative(a) & !is_positive(b) -> !is_positive(a * b) by {
    a * b = negate(from_nat(nat.mul(abs(a), abs(b))))
    !is_positive(negate(from_nat(nat.mul(abs(a), abs(b)))))
}

theorem mul_nonpos_nonneg_nonpos(a: Int, b: Int): !is_positive(a) & !is_negative(b) -> !is_positive(a * b) by {
    a * b = negate(from_nat(nat.mul(abs(a), abs(b))))
    !is_positive(negate(from_nat(nat.mul(abs(a), abs(b)))))
}

theorem mul_nonpos_nonpos_nonneg(a: Int, b: Int): !is_positive(a) & !is_positive(b) -> !is_negative(a * b) by {
    a * b = from_nat(nat.mul(abs(a), abs(b)))
    !is_negative(from_nat(nat.mul(abs(a), abs(b))))
}

theorem mul_zero_left(a: Int): 0 * a = 0

theorem mul_comm(a: Int, b: Int): a * b = b * a by {
    if is_positive(a) {
        if is_positive(b) {
            a * b = from_nat(nat.mul(abs(a), abs(b)))
            b * a = from_nat(nat.mul(abs(b), abs(a)))
            a * b = b * a
        } else {
            a * b = negate(from_nat(nat.mul(abs(a), abs(b))))
            b * a = negate(from_nat(nat.mul(abs(b), abs(a))))
            a * b = b * a
        }
    } else {
        if is_positive(b) {
            a * b = negate(from_nat(nat.mul(abs(a), abs(b))))
            b * a = negate(from_nat(nat.mul(abs(b), abs(a))))
            a * b = b * a
        } else {
            a * b = from_nat(nat.mul(abs(a), abs(b)))
            b * a = from_nat(nat.mul(abs(b), abs(a)))
            a * b = b * a
        }
    }
}

theorem mul_one_right(a: Int): a * 1 = a by {
    is_positive(1)
    a * 1 = mul_nat(a, nat.1)
    if is_positive(a) {
        a * 1 = from_nat(nat.mul(abs(a), nat.1))
        a * 1 = from_nat(abs(a))
        a * 1 = a
    } else {
        a * 1 = negate(from_nat(nat.mul(abs(a), nat.1)))
        negate(from_nat(abs(a))) = 0 + a
        mul_nat(a, nat.0) + a = negate(from_nat(abs(a)))
        a * 1 = negate(from_nat(abs(a)))
        a * 1 = a
    }
}

theorem mul_one_left(a: Int): 1 * a = a

theorem mul_neg_left(a: Int, b: Int): negate(a) * b = negate(a * b) by {
    if is_positive(a) {
        if is_positive(b) {
            negate(a) * b = negate(a * b)
        } else {
            negate(a) * b = negate(a * b)
        }
    } else {
        if is_positive(b) {
            negate(a) * b = negate(a * b)
        } else {
            negate(a) * b = negate(a * b)
        }
    }
}

theorem mul_neg_right(a: Int, b: Int): a * negate(b) = negate(a * b)

theorem mul_distrib_nonneg_right(a: Int, b: Int, c: Int): !is_negative(c) -> (a + b) * c = a * c + b * c by {
    (a + b) * c = mul_nat(a + b, abs(c))
    (a + b) * c = mul_nat(a, abs(c)) + mul_nat(b, abs(c))
    (a + b) * c = a * c + mul_nat(b, abs(c))
    (a + b) * c = a * c + b * c
}

theorem mul_distrib_right(a: Int, b: Int, c: Int): (a + b) * c = a * c + b * c by {
    if is_negative(c) {
        is_positive(negate(c))
        (a + b) * negate(c) = a * negate(c) + b * negate(c)
        (a + b) * negate(c) = negate(a * c) + b * negate(c)
        (a + b) * negate(c) = negate(a * c) + negate(b * c)
        (a + b) * negate(c) = negate(a * c + b * c)
        negate((a + b) * c) = negate(a * c + b * c)
        (a + b) * c = a * c + b * c
    } else {
        (a + b) * c = a * c + b * c
    }
}

theorem mul_distrib_left(a: Int, b: Int, c: Int): a * (b + c) = a * b + a * c by {
    a * (b + c) = (b + c) * a
    a * (b + c) = b * a + c * a
    a * (b + c) = a * b + c * a
}

theorem mul_sub_distrib_right(a: Int, b: Int, c: Int): (a - b) * c = a * c - b * c by {
    (a - b) * c = (a + negate(b)) * c
    (a - b) * c = a * c + negate(b) * c
    (a - b) * c = a * c + negate(b * c)
    (a - b) * c = a * c - b * c
}

theorem mul_sub_distrib_left(a: Int, b: Int, c: Int): a * (b - c) = a * b - a * c by {
    a * (b - c) = a * (b + negate(c))
    a * (b - c) = a * b + a * negate(c)
    a * (b - c) = a * b + negate(a * c)
    a * (b - c) = a * b - a * c
}

theorem abs_mul(a: Int, b: Int): abs(a * b) = nat.mul(abs(a), abs(b)) by {
    if is_positive(a) {
        if is_positive(b) {
            abs(a * b) = nat.mul(abs(a), abs(b))
        } else {
            abs(mul_nat(a, abs(b))) = abs(a * b)
            abs(a * b) = nat.mul(abs(a), abs(b))
        }
    } else {
        if is_positive(b) {
            abs(a * b) = abs(b * a)
            nat.mul(abs(a), abs(b)) = nat.mul(abs(b), abs(a))
            abs(mul_nat(b, abs(a))) = abs(b * a)
            nat.mul(pos_part(b), abs(a)) = abs(a * b)
            abs(a * b) = nat.mul(abs(a), abs(b))
        } else {
            abs(a * b) = nat.mul(abs(a), abs(b))
        }
    }
}

theorem mul_from_nat(j: Nat, k: Nat): from_nat(j) * from_nat(k) = from_nat(nat.mul(j, k)) by {
    abs(from_nat(j) * from_nat(k)) = nat.mul(abs(from_nat(j)), abs(from_nat(k)))
    from_nat(abs(from_nat(j) * from_nat(k))) = from_nat(nat.mul(abs(from_nat(j)), abs(from_nat(k))))
    !is_negative(from_nat(j))
    !is_negative(from_nat(k))
    !is_negative(from_nat(j) * from_nat(k))
    from_nat(abs(from_nat(j) * from_nat(k))) = from_nat(j) * from_nat(k)
    from_nat(j) * from_nat(k) = from_nat(nat.mul(abs(from_nat(j)), abs(from_nat(k))))
}

theorem abs_zero_imp_zero(a: Int): abs(a) = nat.0 -> a = 0 by {
    !is_negative(a)
    !is_positive(a)
}

theorem mul_zero_imp_factor_zero(a: Int, b: Int): a * b = 0 -> a = 0 | b = 0 by {
    nat.mul(abs(a), abs(b)) = nat.0
    abs(a) = nat.0 | abs(b) = nat.0
    if abs(a) = nat.0 {
        a = 0
    } else {
        b = 0
    }
}

theorem mul_pos_pos(a: Int, b: Int): is_positive(a) & is_positive(b) -> is_positive(a * b) by {
    !is_negative(a)
    !is_negative(b)
    !is_negative(a * b)
    if a * b = 0 {
        if a = 0 {
            !is_positive(a)
            false
        } else {
            b = 0
            !is_positive(b)
            false
        }
    } else {
        is_positive(a * b)
    }
}

theorem mul_pos_neg(a: Int, b: Int): is_positive(a) & is_negative(b) -> is_negative(a * b)

theorem mul_neg_pos(a: Int, b: Int): is_negative(a) & is_positive(b) -> is_negative(a * b)

theorem mul_neg_neg(a: Int, b: Int): is_negative(a) & is_negative(b) -> is_positive(a * b) by {
    is_positive(negate(a))
    is_negative(negate(a) * b)
    is_negative(negate(a * b))
    is_positive(a * b)
}

theorem mul_int_nat_nat_assoc(a: Int, j: Nat, k: Nat): mul_nat(a, nat.mul(j, k)) = mul_nat(mul_nat(a, j), k) by {
    if is_negative(a) {
        // Simplify lhs
        a = negate(from_nat(abs(a)))
        mul_nat(a, nat.mul(j, k)) = negate(from_nat(nat.mul(abs(a), nat.mul(j, k))))
        mul_nat(a, nat.mul(j, k)) = negate(from_nat(nat.mul(nat.mul(abs(a), j), k)))
        
        // Simplify rhs
        mul_nat(a, j) = negate(from_nat(nat.mul(abs(a), j)))
        mul_nat(mul_nat(a, j), k) = mul_nat(negate(from_nat(nat.mul(abs(a), j))), k)
        mul_nat(mul_nat(a, j), k) = negate(mul_nat(from_nat(nat.mul(abs(a), j)), k))
        mul_nat(mul_nat(a, j), k) = negate(from_nat(nat.mul(nat.mul(abs(a), j), k)))

        // Conclusion
        mul_nat(a, nat.mul(j, k)) = mul_nat(mul_nat(a, j), k)
    } else {
        // Simplify lhs
        mul_nat(a, nat.mul(j, k)) = from_nat(nat.mul(abs(a), nat.mul(j, k)))
        mul_nat(a, nat.mul(j, k)) = from_nat(nat.mul(nat.mul(abs(a), j), k))
        
        // Simplify rhs
        mul_nat(a, j) = from_nat(nat.mul(abs(a), j))
        mul_nat(mul_nat(a, j), k) = mul_nat(from_nat(nat.mul(abs(a), j)), k)
        mul_nat(mul_nat(a, j), k) = from_nat(nat.mul(nat.mul(abs(a), j), k))

        // Conclusion
        mul_nat(a, nat.mul(j, k)) = mul_nat(mul_nat(a, j), k)
    }
}

theorem mul_int_int_nat_assoc(a: Int, b: Int, n: Nat): mul_nat(a * b, n) = a * mul_nat(b, n) by {
    if is_negative(b) {
        b = negate(from_nat(abs(b)))
        mul_nat(a * b, n) = mul_nat(a * negate(from_nat(abs(b))), n)
        mul_nat(a * b, n) = mul_nat(negate(mul_nat(a, abs(b))), n)
        mul_nat(a * b, n) = negate(mul_nat(mul_nat(a, abs(b)), n))
        mul_nat(a * b, n) = negate(mul_nat(a, nat.mul(abs(b), n)))
        mul_nat(a * b, n) = negate(a * from_nat(nat.mul(abs(b), n)))
        mul_nat(a * b, n) = a * negate(from_nat(nat.mul(abs(b), n)))
        mul_nat(a * b, n) = a * mul_nat(negate(from_nat(abs(b))), n)
        mul_nat(a * b, n) = a * mul_nat(b, n)
    } else {
        a * b = mul_nat(a, abs(b))
        mul_nat(a, nat.mul(abs(b), n)) = mul_nat(a * b, n)
        from_nat(nat.mul(abs(b), n)) = mul_nat(b, n)
        mul_nat(a, nat.mul(abs(b), n)) = a * mul_nat(b, n)
        mul_nat(a * b, n) = a * mul_nat(b, n)
    }
}

theorem mul_assoc(a: Int, b: Int, c: Int): a * b * c = a * (b * c) by {
    if is_negative(c) {
        c = negate(from_nat(abs(c)))
        a * b * c = a * b * negate(from_nat(abs(c)))
        a * b * c = negate(a * b * from_nat(abs(c)))
        a * b * c = negate(mul_nat(a * b, abs(c)))
        a * b * c = negate(a * mul_nat(b, abs(c)))
        a * b * c = a * negate(mul_nat(b, abs(c)))
        a * b * c = a * negate(b * from_nat(abs(c)))
        a * b * c = a * (b * negate(from_nat(abs(c))))
        a * b * c = a * (b * c)
    } else {
        c = from_nat(abs(c))
        a * b * c = a * b * from_nat(abs(c))
        a * b * c = mul_nat(a * b, abs(c))
        a * b * c = a * mul_nat(b, abs(c))
        a * b * c = a * (b * from_nat(abs(c)))
        a * b * c = a * (b * c)
    }
}

// Comparison operators

class Int {
    define lt(self: Int, b: Int) -> Bool: is_positive(b - self)
    define lte(self: Int, b: Int) -> Bool: (self < b) | self = b
}

theorem lt_not_ref(a: Int): !(a < a) by {
    if a < a {
        is_positive(a - a)
        is_positive(0)
        false
    }
}

theorem lte_ref(a: Int): a <= a

theorem zero_lt_pos(a: Int): is_positive(a) -> 0 < a

theorem neg_lt_zero(a: Int): is_negative(a) -> a < 0

theorem nonpos_lt_pos(a: Int, b: Int): !is_positive(a) & is_positive(b) -> a < b

theorem neg_lt_nonneg(a: Int, b: Int): is_negative(a) & !is_negative(b) -> a < b

theorem nonpos_lte_nonneg(a: Int, b: Int): !is_positive(a) & !is_negative(b) -> a <= b

theorem lte_abs(a: Int): a <= from_nat(abs(a)) by {
    if is_negative(a) {
        a <= from_nat(abs(a))
    } else {
        a <= from_nat(abs(a))
    }
}

theorem lt_add_left(a: Int, b: Int, c: Int): b < c -> a + b < a + c by {
    is_positive(c - b)
    (a + c) - (a + b) = c - b
    is_positive((a + c) - (a + b))
}

theorem lte_add_left(a: Int, b: Int, c: Int): b <= c -> a + b <= a + c

theorem abs_add_nonneg(a: Int, b: Int):
    !is_negative(a) & !is_negative(b) -> abs(a + b) = nat.add(abs(a), abs(b)) by {
    from_nat(abs(a)) = a
    from_nat(abs(b)) = b
    from_nat(abs(a)) + from_nat(abs(b)) = from_nat(nat.add(abs(a), abs(b)))
    a + from_nat(abs(b)) = from_nat(nat.add(abs(a), abs(b)))
    a + b = from_nat(nat.add(abs(a), abs(b)))
}

theorem abs_add_nonpos(a: Int, b: Int):
    !is_positive(a) & !is_positive(b) -> abs(a + b) = nat.add(abs(a), abs(b)) by {
    !is_negative(negate(a))
    !is_negative(negate(b))
    abs(negate(a) + negate(b)) = nat.add(abs(negate(a)), abs(negate(b)))
    abs(negate(a + b)) = nat.add(abs(negate(a)), abs(negate(b)))
    abs(negate(a + b)) = nat.add(abs(a), abs(b))
}

// One case of the triangle inequality
theorem triangle_nonpos_lte_nonneg(a: Int, b: Int):
    !is_negative(a) & !is_positive(b) & nat.lte(abs(b), abs(a)) -> nat.lte(abs(a + b), nat.add(abs(a), abs(b))) by {
    exists(n: Nat) { nat.add(n, abs(b)) = abs(a) }
    from_nat(n) + from_nat(abs(b)) = from_nat(abs(a))
    from_nat(n) + negate(b) = from_nat(abs(a))
    from_nat(n) + negate(b) = a
    a + b = from_nat(n)
    abs(a + b) = n
    nat.lte(n, abs(a))
    nat.lte(abs(a), nat.add(abs(a), abs(b)))
    nat.lte(n, nat.add(abs(a), abs(b)))
}

theorem triangle_nonneg_nonpos(a: Int, b: Int):
    !is_negative(a) & !is_positive(b) -> nat.lte(abs(a + b), nat.add(abs(a), abs(b))) by {
    if nat.lte(abs(b), abs(a)) {
        nat.lte(abs(a + b), nat.add(abs(a), abs(b)))
    } else {
        nat.lte(abs(a), abs(b))
        nat.lte(abs(negate(a)), abs(negate(b)))
        !is_negative(negate(b))
        !is_positive(negate(a))
        nat.lte(abs(negate(b) + negate(a)), nat.add(abs(negate(b)), abs(negate(a))))
        nat.lte(abs(negate(b + a)), nat.add(abs(negate(b)), abs(negate(a))))
        nat.lte(abs(b + a), nat.add(abs(negate(b)), abs(negate(a))))
        nat.lte(abs(b + a), nat.add(abs(b), abs(a)))
        nat.lte(abs(a + b), nat.add(abs(b), abs(a)))        
        nat.lte(abs(a + b), nat.add(abs(a), abs(b)))
    }
}

theorem triangle_ineq(a: Int, b: Int): nat.lte(abs(a + b), nat.add(abs(a), abs(b))) by {
    if is_negative(a) {
        if is_negative(b) {
            abs(a + b) = nat.add(abs(a), abs(b))
            nat.lte(abs(a + b), nat.add(abs(a), abs(b)))
        } else {
            nat.lte(abs(b + a), nat.add(abs(b), abs(a)))
            nat.lte(abs(b + a), nat.add(abs(a), abs(b)))
            nat.lte(abs(a + b), nat.add(abs(a), abs(b)))
        }
    } else {
        if is_negative(b) {
            nat.lte(abs(a + b), nat.add(abs(a), abs(b)))
        } else {
            abs(a + b) = nat.add(abs(a), abs(b))
            nat.lte(abs(a + b), nat.add(abs(a), abs(b)))
        }
    }
}

theorem lt_mul_pos(a: Int, b: Int, c: Int): a < b & is_positive(c) -> a * c < b * c by {
    b * c - a * c = (b - a) * c
    b * c - a * c = c * (b - a)
    is_positive(b - a)
    is_positive(b * c - a * c)
}

theorem lt_mul_neg(a: Int, b: Int, c: Int): a < b & is_negative(c) -> b * c < a * c by {
    a * c - b * c = c * (a - b)
    is_positive(b - a)
    is_negative(a - b)
    is_positive(c * (a - b))
    is_positive(a * c - b * c)
}

theorem lt_trans(a: Int, b: Int, c: Int): a < b & b < c -> a < c by {
    is_positive(b - a)
    is_positive(c - b)
    exists(k0: Int) { a + k0 < c + k0 }
    is_positive(c - a)
}

theorem lte_trans(a: Int, b: Int, c: Int): a <= b & b <= c -> a <= c by {
    if a = b {
        a <= c
    } else {
        a < b
        if b = c {
            a <= c
        } else {
            b < c
            a < c
            a <= c
        }
    }
}

theorem lt_and_lte(a: Int, b: Int, c: Int): a < b & b <= c -> a < c by {
    if b = c {
        a < c
    } else {
        a < c
    }
}

theorem lte_and_lt(a: Int, b: Int, c: Int): a <= b & b < c -> a < c by {
    if a = b {
        a < c
    } else {
        a < c
    }
}

theorem lt_from_nat(j: Nat, k: Nat): nat.lt(j, k) -> from_nat(j) < from_nat(k) by {
    exists(d: Nat) { nat.add(d, j) = k & d != nat.0 }
    from_nat(d) + from_nat(j) = from_nat(k)
    from_nat(k) - from_nat(j) = from_nat(d)
    is_positive(from_nat(d))
}

theorem lte_from_nat(j: Nat, k: Nat): nat.lte(j, k) -> from_nat(j) <= from_nat(k) by {
    if j = k {
        from_nat(j) = from_nat(k)
        from_nat(j) <= from_nat(k)
    } else {
        nat.lt(j, k)
        from_nat(j) < from_nat(k)
        from_nat(j) <= from_nat(k)
    }
}

// Units and dividing

define is_unit(a: Int) -> Bool: abs(a) = nat.1

theorem two_units(u: Int): is_unit(u) -> u = 1 | u = negate(1)

theorem unit_squared(u: Int): is_unit(u) -> u * u = 1 by {
    if u = 1 {
        u * u = 1
    } else {
        u * u = 1
    }
}

theorem mul_units(u: Int, v: Int): is_unit(u) & is_unit(v) -> is_unit(u * v) by {
    abs(u * v) = nat.mul(abs(u), abs(v))
    abs(u) = nat.1
    abs(v) = nat.1
    abs(u * v) = nat.1
}

// Like the sign function, but we force it to be a unit, by considering 0 to have sign 1
define unit_sign(a: Int) -> Int: if is_negative(a) {
    negate(1)
} else {
    1
}

theorem unit_sign_is_unit(a: Int): is_unit(unit_sign(a)) by {
    if is_negative(a) {
        unit_sign(a) = negate(1)
        abs(negate(1)) = nat.1
        is_unit(unit_sign(a))
    } else {
        unit_sign(a) = 1
        abs(1) = nat.1
        is_unit(unit_sign(a))
    }
}

theorem abs_decomp(a: Int): unit_sign(a) * from_nat(abs(a)) = a by {
    if is_negative(a) {
        unit_sign(a) = negate(1)
        unit_sign(a) * from_nat(abs(a)) = negate(1) * from_nat(abs(a))
        unit_sign(a) * from_nat(abs(a)) = negate(from_nat(abs(a)))
        unit_sign(a) * from_nat(abs(a)) = a
    } else {
        unit_sign(a) = 1
        unit_sign(a) * from_nat(abs(a)) = 1 * from_nat(abs(a))
        unit_sign(a) * from_nat(abs(a)) = from_nat(abs(a))
        unit_sign(a) * from_nat(abs(a)) = a
    }
}

theorem abs_alt_decomp(a: Int): unit_sign(a) * a = from_nat(abs(a)) by {
    unit_sign(a) * a = unit_sign(a) * (unit_sign(a) * from_nat(abs(a)))
    unit_sign(a) * a = unit_sign(a) * unit_sign(a) * from_nat(abs(a))
    unit_sign(a) * unit_sign(a) = 1
    unit_sign(a) * a = 1 * from_nat(abs(a))
}

define divides(a: Int, b: Int) -> Bool: exists(d: Int) { d * a = b }

theorem div_trans(a: Int, b: Int, c: Int): divides(a, b) & divides(b, c) -> divides(a, c) by {
    exists(d: Int) { d * a = b }
    exists(e: Int) { e * b = c }
    e * (d * a) = c
    e * d * a = c
    divides(a, c)
}

theorem div_imp_div_abs(a: Int, b: Int): divides(a, b) -> nat.divides(abs(a), abs(b)) by {
    exists(d: Int) { d * a = b }
    nat.mul(abs(d), abs(a)) = abs(b)
    nat.divides(abs(a), abs(b))
}

theorem div_from_nat(j: Nat, k: Nat): nat.divides(j, k) -> divides(from_nat(j), from_nat(k)) by {
    exists(n: Nat) { nat.mul(n, j) = k }
    from_nat(n) * from_nat(j) = from_nat(k)
    divides(from_nat(j), from_nat(k))
}

theorem div_abs(a: Int): divides(a, from_nat(abs(a))) by {
    from_nat(abs(a)) = a * unit_sign(a)
}

theorem div_abs_imp_div(a: Int, b: Int): nat.divides(abs(a), abs(b)) -> divides(a, b) by {
    divides(from_nat(abs(a)), from_nat(abs(b)))
    divides(a, from_nat(abs(a)))
    divides(a, from_nat(abs(b)))
    divides(from_nat(abs(b)), b)
}

theorem abs_eq_imp_unit(a: Int, b: Int): abs(a) = abs(b) -> exists(u: Int) { is_unit(u) & u * a = b } by {
    from_nat(abs(a)) = from_nat(abs(b))
    unit_sign(a) * a = from_nat(abs(a))
    b = unit_sign(b) * from_nat(abs(b))
    b = unit_sign(b) * from_nat(abs(a))
    b = unit_sign(b) * unit_sign(a) * a
    b = unit_sign(b) * unit_sign(a) * a
    is_unit(unit_sign(b))
    is_unit(unit_sign(a))
    is_unit(unit_sign(b) * unit_sign(a))
}

theorem abs_eq_imp_div(a: Int, b: Int): abs(a) = abs(b) -> divides(a, b) by {
    exists(u: Int) { is_unit(u) & u * a = b }
}

theorem div_pos_imp_lte(a: Int, b: Int): divides(a, b) & is_positive(b) -> a <= b by {
    nat.divides(abs(a), abs(b))
    from_nat(abs(a)) <= from_nat(abs(b))
    from_nat(abs(a)) <= b
    a <= from_nat(abs(a))
    a <= b
}

// Theorems that relate to the GCD

define gcd(a: Int, b: Int) -> Int: from_nat(nat_gcd.gcd(abs(a), abs(b)))

theorem gcd_nonneg(a: Int, b: Int): !is_negative(gcd(a, b))

theorem gcd_comm(a: Int, b: Int): gcd(a, b) = gcd(b, a) by {
    from_nat(nat_gcd.gcd(abs(a), abs(b))) = from_nat(nat_gcd.gcd(abs(b), abs(a)))
}

theorem gcd_div_left(a: Int, b: Int): divides(gcd(a, b), a) by {
    divides(from_nat(nat_gcd.gcd(abs(a), abs(b))), a)
}

theorem gcd_div_right(a: Int, b: Int): divides(gcd(a, b), b)

theorem divides_gcd(a: Int, b: Int, d: Int): divides(d, a) & divides(d, b) -> divides(d, gcd(a, b)) by {
    nat.divides(abs(d), abs(a))
    nat.divides(abs(d), abs(b))
    nat.divides(abs(d), nat_gcd.gcd(abs(a), abs(b)))
    divides(d, from_nat(nat_gcd.gcd(abs(a), abs(b))))
    divides(d, gcd(a, b))
}

theorem gcd_pos(a: Int, b: Int): a != 0 & b != 0 -> is_positive(gcd(a, b)) by {
    abs(a) != nat.0
    abs(b) != nat.0
    nat_gcd.gcd(abs(a), abs(b)) != nat.0
    gcd(a, b) != 0
}

theorem gcd_is_gcd(a: Int, b: Int, d: Int): a != 0 & b != 0 & divides(d, a) & divides(d, b) -> d <= gcd(a, b) by {
    is_positive(gcd(a, b))
    divides(d, gcd(a, b))
}

// Theorems about the span of a linear combination

define spans(a: Int, b: Int, c: Int) -> Bool: exists(d: Int, e: Int) {
    d * a + e * b = c
}

theorem spans_zero(a: Int, b: Int): spans(a, b, 0) by {
    0 * a + 0 * b = 0
}

theorem spans_left(a: Int, b: Int): spans(a, b, a) by {
    1 * a + 0 * b = a
}

theorem spans_comm(a: Int, b: Int, c: Int): spans(a, b, c) -> spans(b, a, c) by {
    exists(d: Int, e: Int) { d * a + e * b = c }
    e * b + d * a = c
}

theorem spans_right(a: Int, b: Int): spans(a, b, b) by {
    0 * a + 1 * b = b
}

theorem spans_mul_left(a: Int, b: Int, c: Int): spans(a, b, c * a) by {
    c * a + 0 * b = c * a
}

theorem spans_div_left(a: Int, b: Int, c: Int): divides(a, c) -> spans(a, b, c)

theorem spans_mul_right(a: Int, b: Int, c: Int): spans(a, b, c * b)

theorem spans_div_right(a: Int, b: Int, c: Int): divides(b, c) -> spans(a, b, c) by {
    spans(b, a, c)
}

theorem spans_mul(a: Int, b: Int, c: Int, d: Int): spans(a, b, c) -> spans(a, b, d * c) by {
    exists(e: Int, f: Int) { e * a + f * b = c }
    d * c = d * (e * a + f * b)
    d * c = d * (e * a) + d * (f * b)
    d * c = d * e * a + d * f * b
}

theorem spans_add(a: Int, b: Int, c: Int, d: Int): spans(a, b, c) & spans(a, b, d) -> spans(a, b, c + d) by {
    exists(e: Int, f: Int) { e * a + f * b = c }
    exists(g: Int, h: Int) { g * a + h * b = d }
    c + d = (e * a + f * b) + (g * a + h * b)
    c + d = (e * a + g * a) + (f * b + h * b)
    c + d = (e + g) * a + (f + h) * b
}

theorem spans_negate(a: Int, b: Int, c: Int): spans(a, b, c) -> spans(a, b, negate(c)) by {
    negate(1) * c = negate(c)
    spans(a, b, negate(1) * c)
}

let mod: (Nat, Nat) -> Nat = nat.mod

theorem spans_nat_mod(a: Int, b: Int, k: Nat, m: Nat):
    spans(a, b, from_nat(k)) & spans(a, b, from_nat(m)) -> spans(a, b, from_nat(mod(k, m)))
by {
    exists(d: Nat) { nat.add(nat.mul(d, m), mod(k, m)) = k }
    from_nat(nat.mul(d, m)) + from_nat(mod(k, m)) = from_nat(k)
    from_nat(d) * from_nat(m) + from_nat(mod(k, m)) = from_nat(k)
    from_nat(mod(k, m)) = from_nat(k) + negate(from_nat(d) * from_nat(m))
    spans(a, b, negate(from_nat(d) * from_nat(m)))
    spans(a, b, from_nat(mod(k, m)))
}

// Bezout's identity
theorem spans_gcd(a: Int, b: Int): spans(a, b, gcd(a, b)) by {
    let f: Nat -> Bool = function(n: Nat) {
        spans(a, b, from_nat(n))
    }
    nat_gcd.mod_maintains(f)
    f(abs(a))
    f(abs(b))
    spans(a, b, from_nat(nat_gcd.gcd(abs(a), abs(b))))
}