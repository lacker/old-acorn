import nat
import subtraction
type Nat: nat.Nat
type Int: axiom

let from_nat: Nat -> Int = axiom
let negate: Int -> Int = axiom
let abs: Int -> Nat = axiom

let 0: Int = from_nat(nat.0)
let 1: Int = from_nat(nat.1)

axiom neg_zero: negate(0) = 0

axiom neg_neg(a: Int): negate(negate(a)) = a

axiom abs_neg(a: Int): abs(negate(a)) = abs(a)

axiom abs_from_nat(n: Nat): abs(from_nat(n)) = n

axiom neg_or_pos(a: Int): a = from_nat(abs(a)) | a = negate(from_nat(abs(a)))

axiom fix_neg(a: Int): negate(a) = a -> a = 0

// Subtraction that goes from naturals into integers
define sub_nat(m: Nat, n: Nat) -> Int = if nat.lte(n, m) {
    from_nat(subtraction.sub(m, n))
    } else {
    negate(from_nat(subtraction.sub(n, m)))
}

theorem abs_zero: abs(0) = nat.0

theorem sub_nat_zero_right(n: Nat): sub_nat(n, nat.0) = from_nat(n)

theorem sub_nat_zero_left(n: Nat): sub_nat(nat.0, n) = negate(from_nat(n))

theorem sub_nat_self(n: Nat): sub_nat(n, n) = 0

theorem neg_sub_nat(m: Nat, n: Nat): sub_nat(m, n) = negate(sub_nat(n, m)) by {
    if m = n {
        sub_nat(m, n) = 0
        sub_nat(m, n) = negate(0)
        sub_nat(m, n) = negate(sub_nat(n, m))
    } else {
        if nat.lte(n, m) {
            !nat.lte(m, n)
            sub_nat(m, n) = negate(sub_nat(n, m))
        } else {
            sub_nat(m, n) = negate(sub_nat(n, m))
        }
    }
}

// Half of a "without loss of generality" sort of reasoning
theorem sub_nat_eq_helper(m: Nat, n: Nat, p: Nat, q: Nat):
    nat.add(m, n) = nat.add(p, q) & nat.lte(p, m) -> sub_nat(m, p) = sub_nat(q, n) by {
    exists(d: Nat) { nat.add(p, d) = m }
    sub_nat(m, p) = from_nat(d)
    nat.add(m, n) = nat.add(nat.add(p, d), n)
    nat.add(p, q) = nat.add(nat.add(p, d), n)
    nat.add(p, q) = nat.add(p, nat.add(d, n))
    q = nat.add(d, n)
    sub_nat(q, n) = from_nat(d)
    sub_nat(m, p) = sub_nat(q, n)
}

theorem sub_nat_eq(m: Nat, n: Nat, p: Nat, q: Nat): nat.add(m, n) = nat.add(p, q) -> sub_nat(m, p) = sub_nat(q, n) by {
    if nat.lte(p, m) {
        sub_nat(m, p) = sub_nat(q, n)
    } else {
        nat.lte(m, p)
        sub_nat(m, p) = sub_nat(q, n)
    }
}

// Can we prove this with sub_nat_eq ?
theorem sub_nat_cancel_right(m: Nat, n: Nat, k: Nat): sub_nat(m, n) = sub_nat(nat.add(m, k), nat.add(n, k)) by {
    if nat.lte(n, m) {
        nat.lte(nat.add(n, k), nat.add(m, k))
        sub_nat(m, n) = from_nat(subtraction.sub(m, n))
        sub_nat(nat.add(m, k), nat.add(n, k)) = from_nat(subtraction.sub(nat.add(m, k), nat.add(n, k)))
        subtraction.sub(m, n) = subtraction.sub(nat.add(m, k), nat.add(n, k))
        sub_nat(m, n) = sub_nat(nat.add(m, k), nat.add(n, k))
    } else {
        !nat.lte(nat.add(n, k), nat.add(m, k))
        sub_nat(m, n) = negate(from_nat(subtraction.sub(n, m)))
        sub_nat(nat.add(m, k), nat.add(n, k)) = negate(from_nat(subtraction.sub(nat.add(n, k), nat.add(m, k))))
        subtraction.sub(n, m) = subtraction.sub(nat.add(n, k), nat.add(m, k))
        sub_nat(m, n) = sub_nat(nat.add(m, k), nat.add(n, k))
    }
}

theorem sub_nat_cancel_left(m: Nat, n: Nat, k: Nat): sub_nat(m, n) = sub_nat(nat.add(k, m), nat.add(k, n))

define is_nonnegative(a: Int) -> bool = a = from_nat(abs(a))

define is_positive(a: Int) -> bool = a != 0 & is_nonnegative(a)

define is_negative(a: Int) -> bool = is_positive(negate(a))

theorem neg_is_neg_abs(a: Int): is_negative(a) -> a = negate(from_nat(abs(a)))

theorem nonneg_imp_not_neg(a: Int): is_nonnegative(a) -> !is_negative(a)

theorem not_neg_imp_nonneg(a: Int): !is_negative(a) -> is_nonnegative(a) by {
    if a = 0 {
        is_nonnegative(a)
    } else {
        negate(a) != 0
        negate(from_nat(abs(a))) != a
        is_nonnegative(a)
    }
}

define pos_part(a: Int) -> Nat = if is_nonnegative(a) {
    abs(a)
} else {
    nat.0
}

define neg_part(a: Int) -> Nat = if is_nonnegative(a) {
    nat.0
} else {
    abs(a)
}

theorem combine_parts(a: Int): sub_nat(pos_part(a), neg_part(a)) = a by {
    if is_nonnegative(a) {
        sub_nat(abs(a), nat.0) = a
        sub_nat(pos_part(a), neg_part(a)) = a
    } else {
        sub_nat(nat.0, abs(a)) = a
        sub_nat(pos_part(a), neg_part(a)) = a
    }
}

define add(a: Int, b: Int) -> Int = sub_nat(nat.add(pos_part(a), pos_part(b)), nat.add(neg_part(a), neg_part(b)))

theorem pos_part_neg(a: Int): pos_part(negate(a)) = neg_part(a) by {
    if is_nonnegative(a) {
        neg_part(a) = nat.0
        pos_part(negate(a)) = nat.0
        pos_part(negate(a)) = neg_part(a)
    } else {
        neg_part(a) = abs(a)
        is_nonnegative(negate(a))
        pos_part(negate(a)) = abs(a)
        pos_part(negate(a)) = neg_part(a)
    }

}

theorem neg_part_neg(a: Int): neg_part(negate(a)) = pos_part(a)

define sub(a: Int, b: Int) -> Int = add(a, negate(b))

theorem add_zero_left(a: Int): add(0, a) = a by {
    pos_part(0) = nat.0
    neg_part(0) = nat.0
    nat.add(pos_part(0), pos_part(a)) = pos_part(a)
    nat.add(neg_part(0), neg_part(a)) = neg_part(a)
    add(0, a) = sub_nat(pos_part(a), neg_part(a))
}

theorem add_zero_right(a: Int): add(a, 0) = a by {
    pos_part(0) = nat.0
    neg_part(0) = nat.0
    nat.add(pos_part(a), pos_part(0)) = pos_part(a)
    nat.add(neg_part(a), neg_part(0)) = neg_part(a)
    add(a, 0) = sub_nat(pos_part(a), neg_part(a))
}

theorem sub_zero(a: Int): sub(a, 0) = a by {
    sub(a, 0) = add(a, negate(0))
    sub(a, 0) = add(a, 0)
    sub(a, 0) = a
}

theorem zero_sub(a: Int): sub(0, a) = negate(a) by {
    sub(0, a) = add(0, negate(a))
    sub(0, a) = negate(a)
}

theorem add_comm(a: Int, b: Int): add(a, b) = add(b, a) by {
    add(a, b) = sub_nat(nat.add(pos_part(b), pos_part(a)), nat.add(neg_part(a), neg_part(b)))
}

theorem neg_distrib(a: Int, b: Int): negate(add(a, b)) = add(negate(a), negate(b)) by {
    nat.add(pos_part(negate(a)), pos_part(negate(b))) = nat.add(neg_part(a), neg_part(b))
    nat.add(neg_part(negate(a)), neg_part(negate(b))) = nat.add(pos_part(a), pos_part(b))
    add(negate(a), negate(b)) = sub_nat(nat.add(pos_part(negate(a)), pos_part(negate(b))),
                                        nat.add(neg_part(negate(a)), neg_part(negate(b))))
    add(negate(a), negate(b)) = sub_nat(nat.add(neg_part(a), neg_part(b)),
                                        nat.add(pos_part(a), pos_part(b)))
    add(negate(a), negate(b)) = negate(sub_nat(nat.add(pos_part(a), pos_part(b)), nat.add(neg_part(a), neg_part(b))))
}

theorem sub_anticomm(a: Int, b: Int): sub(a, b) = negate(sub(b, a)) by {
    negate(sub(b, a)) = negate(add(b, negate(a)))
    negate(sub(b, a)) = add(negate(b), negate(negate(a)))
    negate(sub(b, a)) = add(negate(b), a)
    negate(sub(b, a)) = add(a, negate(b))
}

// theorem add_assoc(a: Int, b: Int, c: Int): add(a, add(b, c)) = add(add(a, b), c) by {
//     add(b, c) = sub_nat(nat.add(pos_part(b), pos_part(c)), nat.add(neg_part(b), neg_part(c)))
// }


