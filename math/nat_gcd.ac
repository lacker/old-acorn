from nat import Nat, NatPair, divides, mod
default Nat

// One step is taking the pair (a, b) and replacing with (b, a mod b).
define gcd_step(p: NatPair) -> NatPair {
    if p.second = 0 {
        p
    } else {
        NatPair.new(p.second, mod(p.first, p.second))
    }
}

// n steps of the gcd algorithm.
define gcd_step_n(p: NatPair, n: Nat) -> NatPair { nat.recursion(gcd_step, p, n) }

define false_below(f: Nat -> Bool, n: Nat) -> Bool { forall(x: Nat) { x < n -> !f(x) } }

theorem all_false_below(f: Nat -> Bool) {
    forall(x: Nat) { false_below(f, x) } -> forall(x: Nat) { !f(x) }
}

// is_min(f, m) tells you whether m is the smallest value for which f is true.
define is_min(f: Nat -> Bool, m: Nat) -> Bool {
    f(m) & false_below(f, m)
}

// If f is true anywhere on the naturals, it has a min.
theorem has_min(f: Nat -> Bool, n: Nat) {
    f(n) -> exists(m: Nat) { is_min(f, m) }
} by {
    define g(x: Nat) -> Bool { has_min(f, x) }
    nat.strong_induction(g)
    forall(k: Nat) {
        if nat.true_below(g, k) {
            if f(k) {
                if false_below(f, k) {
                    is_min(f, k)
                    has_min(f, k)
                } else {
                    exists(a: Nat) { a < k & f(a) }
                    has_min(f, k)
                }
            } else {
                has_min(f, k)
            }
            g(k)
        }
    }
    g(n)
}

// A decreasing_to_zero function strictly decreases until it hits zero.
define decreasing_to_zero(f: Nat -> Nat) -> Bool {
    forall(x: Nat) {
        f(x) = 0 | f(x.suc) < f(x)
    }
}

theorem no_infinite_decreasing(f: Nat -> Nat) {
    exists(x: Nat) { f(x) <= f(x.suc) }
} by {
    if !no_infinite_decreasing(f) {
        forall(x: Nat) {
            !(f(x) <= f(x.suc))
        }
        let h: Nat -> Bool = function(x: Nat) { x + f(x) <= f(0) }
        nat.induction(h)
        0 + f(0) <= f(0)
        h(0)
        forall(x: Nat) {
            if h(x) {
                x + f(x) <= f(0)
                !(f(x) <= f(x.suc))
                f(x.suc) < f(x)
                x + f(x.suc) < x + f(x)
                (x + f(x.suc)).suc <= x + f(x)
                x.suc + f(x.suc) <= x + f(x)
                x.suc + f(x.suc) <= f(0)
                h(x.suc)
            }
        }
        forall(x: Nat) {
            h(x)
        }
        h(f(0).suc)
        f(0).suc + f(f(0).suc) <= f(0)
        f(0).suc <= f(0).suc + f(f(0).suc)
        let z: Nat = f(0).suc + f(f(0).suc)
        z <= f(0)
        f(0).suc <= z
        f(0).suc <= f(0)
        false
    }    
}

theorem dtz_terminates(f: Nat -> Nat) {
    decreasing_to_zero(f) -> exists(n: Nat) { f(n) = 0 }
} by {
    let (n: Nat) satisfy { f(n) <= f(n.suc) }
    f(n) = 0 | f(n.suc) < f(n)
    f(n) = 0
}

theorem gcd_terminates(p: NatPair) {
    exists(n: Nat) { gcd_step_n(p, n).second = 0 }
} by {
    let f: Nat -> Nat = function(x: Nat) { gcd_step_n(p, x).second }
    forall(x: Nat) {
        if f(x) != 0 {
            let q: NatPair = gcd_step_n(p, x)
            gcd_step_n(p, x.suc) = gcd_step(gcd_step_n(p, x))
            gcd_step_n(p, x.suc) = gcd_step(q)
            f(x.suc) = gcd_step_n(p, x.suc).second
            f(x.suc) = gcd_step(q).second
            q.second != 0
            gcd_step(q) = NatPair.new(q.second, mod(q.first, q.second))
            f(x.suc) = mod(q.first, q.second)
            f(x.suc) = mod(q.first, f(x))
            mod(q.first, f(x)) < f(x)
            f(x.suc) < f(x)
        }
    }
    decreasing_to_zero(f)
    dtz_terminates(f)
}

define gcd_termination(p: NatPair) -> (Nat -> Bool) {
    function(n: Nat) {
        gcd_step_n(p, n).second = 0
    }
}

let num_gcd_steps(p: NatPair) -> n: Nat satisfy {
    is_min(gcd_termination(p), n)
}

theorem num_gcd_steps_terminates(p: NatPair) { gcd_step_n(p, num_gcd_steps(p)).second = 0 } by {
    exists(n: Nat) { is_min(gcd_termination(p), n) }
    let f: Nat -> Bool = gcd_termination(p)
    is_min(f, num_gcd_steps(p))
    gcd_termination(p)(num_gcd_steps(p))
}

define gcd_pair(p: NatPair) -> Nat { gcd_step_n(p, num_gcd_steps(p)).first }

define gcd(a: Nat, b: Nat) -> Nat { gcd_pair(NatPair.new(a, b)) }

define divides_both(a: Nat, p: NatPair) -> Bool { divides(a, p.first) & divides(a, p.second) }

theorem divides_both_step(a: Nat, p: NatPair) { divides_both(a, p) -> divides_both(a, gcd_step(p)) } by {
    divides(a, p.first)
    divides(a, p.second)
    divides(a, mod(p.first, p.second))
    if p.second = 0 {
        divides_both(a, gcd_step(p))
    } else {
        gcd_step(p) = NatPair.new(p.second, mod(p.first, p.second))
        gcd_step(p).second = mod(p.first, p.second)
        divides(a, gcd_step(p).second)
        gcd_step(p).first = p.second
        divides(a, gcd_step(p).first)
        divides_both(a, gcd_step(p))
    }
}

theorem divides_gcd_step_n(d: Nat, p: NatPair, n: Nat) {
    divides_both(d, p) -> divides_both(d, gcd_step_n(p, n))
} by {
    let f: Nat -> Bool = function(x: Nat) { divides_both(d, gcd_step_n(p, x)) }
    nat.induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            divides_both(d, gcd_step_n(p, x))
            divides_both(d, gcd_step_n(p, x.suc))
            f(x.suc)
        }
    }
    divides_both(d, gcd_step_n(p, n))
}

theorem divides_gcd_pair(d: Nat, p: NatPair) {
    divides_both(d, p) -> divides(d, gcd_pair(p))
}

theorem divides_gcd(d: Nat, a: Nat, b: Nat) { divides(d, a) & divides(d, b) -> divides(d, gcd(a, b)) } by {
    divides_both(d, NatPair.new(a, b))
    divides_gcd_pair(d, NatPair.new(a, b))
    
    divides(d, gcd_pair(NatPair.new(a, b)))
    divides(d, gcd(a, b))
}

theorem divides_both_unstep(a: Nat, p: NatPair) { divides_both(a, gcd_step(p)) -> divides_both(a, p) } by {
    if p.second = 0 {
        p = gcd_step(p)
        divides_both(a, p)
    } else {
        gcd_step(p) = NatPair.new(p.second, mod(p.first, p.second))
        divides(a, p.second)
        divides(a, mod(p.first, p.second))
        divides(a, p.first)
        divides_both(a, p)
    }
}

theorem divides_gcd_step_n_converse(d: Nat, p: NatPair, n: Nat) {
    divides_both(d, gcd_step_n(p, n)) -> divides_both(d, p)
} by {
    let f: Nat -> Bool = function(x: Nat) { divides_gcd_step_n_converse(d, p, x) }
    nat.induction(f)
    divides_gcd_step_n_converse(d, p, 0)
    f(0)
    forall(x: Nat) {
        if f(x) {
            if divides_both(d, gcd_step_n(p, x.suc)) {
                divides_both(d, p)
            }
            divides_gcd_step_n_converse(d, p, x.suc)
            f(x.suc)
        }
    }
}

theorem divides_gcd_pair_converse(d: Nat, p: NatPair) { divides(d, gcd_pair(p)) -> divides_both(d, p) } by {
    gcd_pair(p) = gcd_step_n(p, num_gcd_steps(p)).first
    0 = gcd_step_n(p, num_gcd_steps(p)).second
    divides_both(d, gcd_step_n(p, num_gcd_steps(p)))
    divides_both(d, p)
}

theorem gcd_divides(d: Nat, a: Nat, b: Nat) { divides(d, gcd(a, b)) -> divides(d, a) & divides(d, b) } by {
    let p: NatPair = NatPair.new(a, b)
    p.first = a
    p.second = b
    divides(d, gcd_pair(p))
    divides_both(d, p)    
    divides(d, p.first)
    divides(d, a)
    divides(d, p.second)
    divides(d, b)
    divides(d, a) & divides(d, b)
}

theorem gcd_divides_left(a: Nat, b: Nat) { divides(gcd(a, b), a) } by {
    divides(gcd(a, b), gcd(a, b))
}

theorem gcd_divides_right(a: Nat, b: Nat) { divides(gcd(a, b), b) } by {
    divides(gcd(a, b), gcd(a, b))
}

theorem gcd_is_gcd(a: Nat, b: Nat, d: Nat) {
    a != 0 & b != 0 & divides(d, a) & divides(d, b) -> d <= gcd(a, b)
} by {
    gcd(a, b) != 0
    divides(d, gcd(a, b))
    d <= gcd(a, b)
}

theorem gcd_nonzero_left(a: Nat, b: Nat) { a != 0 -> gcd(a, b) != 0 } by {
    if gcd(a, b) = 0 {
        divides(0, a)
        a = 0
        false
    }
}

theorem gcd_zero_right(a: Nat) { gcd(a, 0) = a } by {
    divides(a, gcd(a, 0))
    divides(gcd(a, 0), a)
}

theorem gcd_zero_left(a: Nat) { gcd(0, a) = a } by {
    divides(a, gcd(0, a))
    divides(gcd(0, a), a)
}

theorem gcd_comm(a: Nat, b: Nat) { gcd(a, b) = gcd(b, a) } by {
    divides(gcd(b, a), gcd(a, b))
    divides(gcd(a, b), gcd(b, a))
}

theorem gcd_nonzero_right(a: Nat, b: Nat) { b != 0 -> gcd(a, b) != 0 }

define mod_maintains(f: Nat -> Bool) -> Bool {
    forall(a: Nat, b: Nat) { f(a) & f(b) -> f(mod(a, b)) }
}

theorem mod_maintains_imp_gcd(f: Nat -> Bool, a: Nat, b: Nat) { mod_maintains(f) & f(a) & f(b) -> f(gcd(a, b)) } by {
    let p: NatPair = NatPair.new(a, b)
    let g: Nat -> Bool = function(n: Nat) {
        f(gcd_step_n(p, n).first) & f(gcd_step_n(p, n).second)
    }
    gcd_step_n(p, 0).first = a
    gcd_step_n(p, 0).second = b
    f(gcd_step_n(p, 0).second)
    g(0)
    forall(x: Nat) {
        if g(x) {
            gcd_step_n(p, x.suc) = gcd_step(gcd_step_n(p, x))
            f(gcd_step_n(p, x).first)
            f(gcd_step_n(p, x).second)

            if gcd_step_n(p, x).second = 0 {
                gcd_step_n(p, x.suc) = gcd_step_n(p, x)
                f(gcd_step_n(p, x.suc).first)
                f(gcd_step_n(p, x.suc).second)
                g(x.suc)
            } else {
                gcd_step_n(p, x.suc).first = gcd_step_n(p, x).second
                NatPair.new(gcd_step_n(p, x).second, mod(gcd_step_n(p, x).first, gcd_step_n(p, x).second)) = gcd_step(gcd_step_n(p, x))
                gcd_step_n(p, x.suc).second = mod(gcd_step_n(p, x).first, gcd_step_n(p, x).second)
                f(gcd_step_n(p, x.suc).first)
                f(mod(gcd_step_n(p, x).first, gcd_step_n(p, x).second))
                f(gcd_step_n(p, x.suc).second)
                g(x.suc)
            }
        }
    }
    g(num_gcd_steps(p))
    f(gcd_step_n(p, num_gcd_steps(p)).first)
    f(gcd(a, b))
}