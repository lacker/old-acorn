// The axioms of Peano arithmetic.
// Contains enough detail that we can prove these with "check".

type Nat: axiom

define 0: Nat = axiom

define Suc: Nat -> Nat = axiom
define 1: Nat = Suc(0)

axiom suc_injective(x: Nat, y: Nat): Suc(x) = Suc(y) -> x = y

axiom suc_neq_zero(x: Nat): Suc(x) != 0

axiom induction(f: Nat -> bool): f(0) & forall(k: Nat) { f(k) -> f(Suc(k)) } -> forall(n: Nat) { f(n) }

// Ideally a and f would be templated rather than just Nat.
define recursion(f: Nat -> Nat, a: Nat, n: Nat) -> Nat = axiom
axiom recursion_base(f: Nat -> Nat, a: Nat): recursion(f, a, 0) = a
axiom recursion_step(f: Nat -> Nat, a: Nat, n: Nat): recursion(f, a, Suc(n)) = f(recursion(f, a, n))

define add(a: Nat, b: Nat) -> Nat = recursion(Suc, a, b)

// Now let's have some theorems.

theorem add_zero_right(a: Nat): add(a, 0) = a

define 2: Nat = Suc(1)

theorem one_plus_one: add(1, 1) = 2

theorem add_zero_left(a: Nat): add(0, a) = a

theorem add_suc_right(a: Nat, b: Nat): add(a, Suc(b)) = Suc(add(a, b))

theorem add_suc_left(a: Nat, b: Nat): add(Suc(a), b) = Suc(add(a, b))

theorem suc_ne(a: Nat): Suc(a) != a by {
    induction(suc_ne)
}

theorem suc_suc_ne(a: Nat): Suc(Suc(a)) != a

theorem add_comm(a: Nat, b: Nat): add(a, b) = add(b, a)

theorem add_assoc(a: Nat, b: Nat, c: Nat): add(add(a, b), c) = add(a, add(b, c)) by {
    let f(x: Nat) -> bool = add_assoc(x, b, c) 
    induction(f)
    forall(x: Nat) {
        if f(x) {
            add(add(Suc(x), b), c) = add(Suc(add(x, b)), c)
            add(add(Suc(x), b), c) = Suc(add(add(x, b), c))
            Suc(add(add(x, b), c)) = Suc(add(x, add(b, c)))
            add(add(Suc(x), b), c) = Suc(add(x, add(b, c)))
            add(add(Suc(x), b), c) = add(Suc(x), add(b, c))
            f(Suc(x))
        }
    }
    f(0)
    f(a)
}

define adder(a: Nat) -> (Nat -> Nat) = function(b: Nat) { add(a, b) }

define mul(a: Nat, b: Nat) -> Nat = recursion(adder(a), 0, b)

theorem mul_zero_right(a: Nat): mul(a, 0) = 0

theorem mul_zero_left(a: Nat): mul(0, a) = 0

theorem mul_suc_right(a: Nat, b: Nat): mul(a, Suc(b)) = add(a, mul(a, b))

theorem mul_suc_left(a: Nat, b: Nat): mul(Suc(a), b) = add(b, mul(a, b)) by {
    let f(x: Nat) -> bool = mul_suc_left(a, x)
    induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            mul(Suc(a), x) = add(x, mul(a, x))
            mul(Suc(a), Suc(x)) = add(Suc(a), mul(Suc(a), x))
            mul(Suc(a), Suc(x)) = add(Suc(a), add(x, mul(a, x)))
            mul(a, Suc(x)) = add(a, mul(a, x))
            add(Suc(a), add(x, mul(a, x))) = add(add(Suc(a), x), mul(a, x))
            add(Suc(a), add(x, mul(a, x))) = add(Suc(add(a, x)), mul(a, x))
            add(Suc(a), add(x, mul(a, x))) = add(Suc(add(x, a)), mul(a, x))
            add(Suc(a), add(x, mul(a, x))) = add(add(Suc(x), a), mul(a, x))
            add_assoc(Suc(x), a, mul(a, x))
            add(add(Suc(x), a), mul(a, x)) = add(Suc(x), add(a, mul(a, x)))
            add(Suc(a), add(x, mul(a, x))) = add(Suc(x), add(a, mul(a, x)))
            mul(Suc(a), Suc(x)) = add(Suc(x), add(a, mul(a, x)))
            mul(Suc(a), Suc(x)) = add(Suc(x), mul(a, Suc(x)))
            f(Suc(x))
        }
    }
    f(b)
}

theorem mul_comm(a: Nat, b: Nat): mul(a, b) = mul(b, a) by {
    let f(x: Nat) -> bool = mul_comm(x, b)
    induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            mul(x, b) = mul(b, x)
            mul(Suc(x), b) = add(b, mul(x, b))
            mul(b, Suc(x)) = add(b, mul(x, b))
            mul(Suc(x), b) = mul(b, Suc(x))
            f(Suc(x))
        }
    }
    f(a)
}

theorem add_comm_4(a: Nat, b: Nat, c: Nat, d: Nat):
    add(add(a, b), add(c, d)) = add(add(a, c), add(b, d))

theorem left_distrib(a: Nat, b: Nat, c: Nat): mul(a, add(b, c)) = add(mul(a, b), mul(a, c)) by {
    let f(x: Nat) -> bool = left_distrib(x, b, c)
    induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            mul(x, add(b, c)) = add(mul(x, b), mul(x, c))
            mul(Suc(x), add(b, c)) = add(add(b, c), mul(x, add(b, c)))
            mul(Suc(x), add(b, c)) = add(add(b, c), add(mul(x, b), mul(x, c)))
            mul(Suc(x), add(b, c)) = add(add(b, c), add(mul(x, b), mul(x, c)))
            mul(Suc(x), add(b, c)) = add(add(b, mul(x, b)), add(c, mul(x, c)))
            mul(Suc(x), add(b, c)) = add(mul(Suc(x), b), mul(Suc(x), c))
            f(Suc(x))
        }
    }
}

theorem right_distrib(a: Nat, b: Nat, c: Nat): mul(add(a, b), c) = add(mul(a, c), mul(b, c))

theorem mul_assoc(a: Nat, b: Nat, c: Nat): mul(mul(a, b), c) = mul(a, mul(b, c)) by {
    let f(x: Nat) -> bool = mul_assoc(x, b, c)
    induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            mul(mul(x, b), c) = mul(x, mul(b, c))
            mul(mul(Suc(x), b), c) = mul(add(b, mul(x, b)), c)
            mul(add(b, mul(x, b)), c) = add(mul(b, c), mul(mul(x, b), c))
            mul(mul(Suc(x), b), c) = add(mul(b, c), mul(mul(x, b), c))
            mul(mul(Suc(x), b), c) = add(mul(b, c), mul(x, mul(b, c)))
            mul(mul(Suc(x), b), c) = mul(Suc(x), mul(b, c))
            f(Suc(x))
        }
    }
}

define lte(a: Nat, b: Nat) -> bool = exists(c: Nat) { add(a, c) = b }

define lt(a: Nat, b: Nat) -> bool = lte(a, b) & a != b

theorem lt_not_ref(a: Nat): !lt(a, a) by {
    if lt(a, a) {
        lt(a, a) & a != a
        a != a
    }
}

theorem adding_to_zero(a: Nat, b: Nat): add(a, b) = 0 -> a = 0 & b = 0

theorem only_zero_lte_zero(a: Nat): lte(a, 0) -> a = 0

theorem not_lt_zero(a: Nat): !lt(a, 0)

theorem zero_or_suc(a: Nat): a = 0 | exists(b: Nat) { a = Suc(b) } by {
    let f(x: Nat) -> bool = (a = 0 | exists(b: Nat) { a = Suc(b) })
    induction(f)
}

theorem lte_cancel_suc(a: Nat, b: Nat): lte(Suc(a), Suc(b)) -> lte(a, b) by {
    if lte(Suc(a), Suc(b)) {
        exists(c: Nat) { add(Suc(a), c) = Suc(b) }
        add(Suc(a), c) = Suc(b)
        Suc(add(a, c)) = Suc(b)
        add(a, c) = b
        lte(a, b)
    }
}

theorem lt_cancel_suc(a: Nat, b: Nat): lt(Suc(a), Suc(b)) -> lt(a, b)

theorem lt_not_symm(a: Nat, b: Nat): lt(a, b) -> !lt(b, a) by {
    let f(x: Nat) -> bool = forall(y: Nat) { lt_not_symm(x, y) }
    induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            forall(y: Nat) {
                if lt(Suc(x), y) {
                    y != 0
                    zero_or_suc(y)
                    y = 0 | exists(z: Nat) { y = Suc(z) }
                    exists(z: Nat) { y = Suc(z) }
                    lt(Suc(x), Suc(z))
                    lt(x, z)
                    !lt(z, x)
                    !lt(Suc(z), Suc(x))
                    !lt(y, Suc(x))
                }
            }
            f(Suc(x))
        }
    }
}

theorem lt_diff(a: Nat, b: Nat): lt(a, b) -> exists(c: Nat) { add(a, c) = b & c != 0 } by {
    if lt(a, b) {
        lte(a, b)
        exists(c: Nat) { add(a, c) = b }
        add(a, c) = b
        c != 0
        lt_diff(a, b)
    }
}

theorem lte_trans(a: Nat, b: Nat, c: Nat): lte(a, b) & lte(b, c) -> lte(a, c) by {
    let f(z: Nat) -> bool = forall(x: Nat, y: Nat) { lte_trans(x, y, z) }
    induction(f)
    f(0)
    forall(z: Nat) {
        if f(z) {
            forall(x: Nat, y: Nat) {
                if lte(x, y) & lte(y, Suc(z)) {
                    lte(x, Suc(z))
                }
                lte_trans(x, y, Suc(z))
            }
            f(Suc(z))
        }
    }
}

theorem lt_add_suc(a: Nat, b: Nat): lt(a, add(a, Suc(b)))

theorem add_cancels_left(a: Nat, b: Nat, c: Nat): add(a, b) = add(a, c) -> b = c by {
    let f(x: Nat) -> bool = add_cancels_left(x, b, c)
    induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            if add(Suc(x), b) = add(Suc(x), c) {
                Suc(add(x, b)) = Suc(add(x, c))
                add(x, b) = add(x, c)
                b = c
            }
            add(Suc(x), b) = add(Suc(x), c) -> b = c
            f(Suc(x))
        }
    }
    f(a)
}

theorem add_cancels_right(a: Nat, b: Nat, c: Nat): add(b, a) = add(c, a) -> b = c by {
    if add(b, a) = add(c, a) {
        add(a, b) = add(a, c)
        b = c
    }
}

theorem lt_suc(a: Nat, b: Nat): lt(a, b) -> Suc(a) = b | lt(Suc(a), b)