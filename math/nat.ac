// The axioms of arithmetic.
// Contains enough detail that we can prove these with "check".
inductive Nat {
    0
    suc(Nat)
}

define repeat<T>(f: T -> T, a: T, n: Nat) -> T { axiom }
axiom repeat_base<T>(f: T -> T, a: T) { repeat(f, a, Nat.0) = a }
axiom repeat_step<T>(f: T -> T, a: T, n: Nat) { repeat(f, a, n.suc) = f(repeat(f, a, n)) }

class Nat {
    let 1: Nat = Nat.0.suc
    let 2: Nat = Nat.1.suc
    let 3: Nat = Nat.2.suc
    let 4: Nat = Nat.3.suc
    let 5: Nat = Nat.4.suc
    let 6: Nat = Nat.5.suc
    let 7: Nat = Nat.6.suc
    let 8: Nat = Nat.7.suc
    let 9: Nat = Nat.8.suc
    let 10: Nat = Nat.9.suc
    define add(self, b: Nat) -> Nat { repeat(Nat.suc, self, b) }
}

numerals Nat


// Now let's have some theorems.

theorem add_zero_right(a: Nat) { a + 0 = a }

theorem one_plus_one { 1 + 1 = 2  } by {
    repeat(Nat.suc, 1, 0).suc = 2
    1 + 0.suc = 2
}

theorem add_zero_left(a: Nat) { 0 + a = a } by {
    Nat.induction(add_zero_left)
    0 + 0 = 0
    add_zero_left(0)
    forall(x: Nat) {
        if add_zero_left(x) {
            0 + x = x
            repeat(Nat.suc, 0, x.suc) = repeat(Nat.suc, 0, x).suc
            0 + x.suc = x.suc
            add_zero_left(x.suc)
        }
    }
}

theorem add_suc_right(a: Nat, b: Nat) {
    a + b.suc = (a + b).suc
} by {
    repeat(Nat.suc, a, b).suc = a + b.suc
}

theorem add_suc_left(a: Nat, b: Nat) { a.suc + b = (a + b).suc } by {
    define f(x: Nat) -> Bool { add_suc_left(a, x) }
    Nat.induction(f)
    a.suc + 0 = (a + 0).suc
    add_suc_left(a, 0)
    f(0)
    forall(x: Nat) {
        if f(x) {
            add_suc_left(a, x)
            a.suc + x.suc = (a + x.suc).suc
            add_suc_left(a, x.suc)
            f(x.suc)
        }
    }
}

theorem add_one_right(a: Nat) {
    a + 1 = a.suc
} by {
    a + 0.suc = a.suc
}

theorem add_one_left(a: Nat) {
    1 + a = a.suc
} by {
    0.suc + a = a.suc
}

theorem suc_ne(a: Nat) { a.suc != a } by {
    Nat.induction(suc_ne)
    suc_ne(0)
    forall(x: Nat) {
        if suc_ne(x) {
            x.suc != x
            x.suc.suc != x.suc
            suc_ne(x.suc)
        }
    }
}

theorem suc_suc_ne(a: Nat) { a.suc.suc != a } by {
    Nat.induction(suc_suc_ne)
    suc_suc_ne(0)
    forall(x: Nat) {
        if suc_suc_ne(x) {
            x.suc.suc != x
            x.suc.suc.suc != x.suc
            suc_suc_ne(x.suc)
        }
    }
}

theorem add_comm(a: Nat, b: Nat) { a + b = b + a } by {
    define f(x: Nat) -> Bool { add_comm(x, b) }
    Nat.induction(f)
    b + 0 = 0 + b
    add_comm(0, b)
    f(0)
    forall(x: Nat) {
        if f(x) {
            add_comm(x, b)
            b + x.suc = (x + b).suc
            b + x.suc = x.suc + b
            add_comm(x.suc, b)
            f(x.suc)
        }
    }
}

theorem add_assoc(a: Nat, b: Nat, c: Nat) { a + b + c = a + (b + c) } by {
    define f(x: Nat) -> Bool { add_assoc(x, b, c) }
    Nat.induction(f)
    forall(x: Nat) {
        if f(x) {
            x.suc + b + c = (x + b + c).suc
            add_assoc(x, b, c)
            x.suc + b + c = x.suc + (b + c)
            add_assoc(x.suc, b, c)
            f(x.suc)
        }
    }
    0 + b + c = 0 + (b + c)
    add_assoc(0, b, c)
    f(0)
}

class Nat {
    define mul(self, b: Nat) -> Nat {
        repeat(Nat.add(self), 0, b)
    }

    define read(self, other: Nat) -> Nat {
        10 * self + other
    }
}

theorem mul_zero_right(a: Nat) { a * 0 = 0 }

theorem mul_zero_left(a: Nat) { 0 * a = 0 } by {
    Nat.induction(mul_zero_left)
    mul_zero_left(0)
    forall(x: Nat) {
        if mul_zero_left(x) {
            0 + 0 * x = 0
            0 + repeat(0.add, 0, x) = 0
            repeat(0.add, 0, x.suc) = 0
            0 * x.suc = 0
            mul_zero_left(x.suc)
        }
    }
}

theorem mul_suc_right(a: Nat, b: Nat) {
    a * b.suc = a + a * b
} by {
    repeat(a.add, 0, b) = a * b
    a + repeat(a.add, 0, b) = repeat(a.add, 0, b.suc)
    repeat(a.add, 0, b.suc) = a * b.suc
}

theorem mul_suc_left(a: Nat, b: Nat) { a.suc * b = b + a * b } by {
    define f(x: Nat) -> Bool { mul_suc_left(a, x) }
    Nat.induction(f)
    0 + a * 0 = 0
    0 + a * 0 = a.suc * 0
    mul_suc_left(a, 0)
    f(0)
    forall(x: Nat) {
        if f(x) {
            mul_suc_left(a, x)
            a.suc * x = x + a * x
            a.suc * x.suc = a.suc + a.suc * x
            a.suc * x.suc = a.suc + (x + a * x)
            a * x.suc = a + a * x
            a.suc + (x + a * x) = a.suc + x + a * x
            a.suc + (x + a * x) = (a + x).suc + a * x
            a.suc + (x + a * x) = (x + a).suc + a * x
            a.suc + (x + a * x) = x.suc + a + a * x
            add_assoc(x.suc, a, a * x)
            x.suc + a + a * x = x.suc + (a + a * x)
            a.suc + (x + a * x) = x.suc + (a + a * x)
            a.suc * x.suc = x.suc + (a + a * x)
            a.suc * x.suc = x.suc + a * x.suc
            mul_suc_left(a, x.suc)
            f(x.suc)
        }
    }
    f(b)
}

theorem mul_one_one { 1 * 1 = 1 } by {
    1 * 1 = 1 * 0.suc
    1 * 1 = 1 + 1 * 0
    1 * 1 = 1 + 0
    1 * 1 = 1
}

theorem mul_comm(a: Nat, b: Nat) { a * b = b * a } by {
    define f(x: Nat) -> Bool { mul_comm(x, b) }
    Nat.induction(f)
    b * 0 = 0 * b
    mul_comm(0, b)
    f(0)
    forall(x: Nat) {
        if f(x) {
            mul_comm(x, b)
            x * b = b * x
            x.suc * b = b + x * b
            b * x.suc = b + x * b
            x.suc * b = b * x.suc
            mul_comm(x.suc, b)
            f(x.suc)
        }
    }
    f(a)
}

theorem add_comm_4(a: Nat, b: Nat, c: Nat, d: Nat) {
    (a + b) + (c + d) = (a + c) + (b + d)
} by {
    a + (b + c) = a + c + b
}

theorem distrib_left(a: Nat, b: Nat, c: Nat) {
    a * (b + c) = a * b + a * c
} by {
    define f(x: Nat) -> Bool { distrib_left(x, b, c) }
    Nat.induction(f)
    0 * b + 0 = 0
    0 * b + 0 * c = 0 * (b + c)
    distrib_left(0, b, c)
    f(0)
    forall(x: Nat) {
        if f(x) {
            distrib_left(x, b, c)
            x * (b + c) = x * b + x * c
            x.suc * (b + c) = b + c + x * (b + c)
            x.suc * (b + c) = b + c + (x * b + x * c)
            x.suc * (b + c) = (b + x * b) + (c + x * c)
            b + x * b = x.suc * b
            c + x * c = x.suc * c
            (b + x * b) + (c + x * c) = x.suc * b + (c + x * c)
            (b + x * b) + (c + x * c) = x.suc * b + x.suc * c
            x.suc * (b + c) = x.suc * b + x.suc * c
            distrib_left(x.suc, b, c)
            f(x.suc)
        }
    }
}

theorem distrib_right(a: Nat, b: Nat, c: Nat) {
    (a + b) * c = a * c + b * c
} by {
    c * a + b * c = c * (a + b)
}

theorem mul_assoc(a: Nat, b: Nat, c: Nat) { a * b * c = a * (b * c) } by {
    define f(x: Nat) -> Bool { mul_assoc(x, b, c) }
    Nat.induction(f)
    0 * b * c = 0 * (b * c)
    mul_assoc(0, b, c)
    f(0)
    forall(x: Nat) {
        if f(x) {
            mul_assoc(x, b, c)
            x * b * c = x * (b * c)
            x.suc * b * c = (b + x * b) * c
            (b + x * b) * c = b * c + x * b * c
            x.suc * b * c = b * c + x * b * c
            x.suc * b * c = b * c + x * (b * c)
            x.suc * b * c = x.suc * (b * c)
            mul_assoc(x.suc, b, c)
            f(x.suc)
        }
    }
}

theorem mul_one_right(a: Nat) { a * 1 = a } by {
    a + a * 0 = a
}

theorem mul_one_left(a: Nat) { 1 * a = a }

// Comparisons

class Nat {
    define lte(self, b: Nat) -> Bool { exists(c: Nat) { self + c = b } }

    define lt(self, b: Nat) -> Bool { self <= b and self != b }
}

theorem lt_not_ref(a: Nat) { not (a < a) }

theorem lte_ref(a: Nat) { a <= a }

theorem add_to_zero(a: Nat, b: Nat) { a + b = 0 -> a = 0 and b = 0 } by {
    define f(x: Nat) -> Bool { add_to_zero(x, b) }
    Nat.induction(f)
    if not add_to_zero(0, b) {
        0 + b = 0
        b != 0
        false
    }
    f(0)
    forall(x: Nat) {
        x.suc + b != 0
        add_to_zero(x.suc, b)
        f(x.suc)
    }
}

theorem only_zero_lte_zero(a: Nat) {
    a <= 0 -> a = 0
} by {
    exists(k0: Nat) { a + k0 = 0 }
}

theorem not_lt_zero(a: Nat) {
    not a < 0
}

theorem zero_or_suc(a: Nat) {
    a = 0 or exists(b: Nat) { a = b.suc }
} by {
    define f(x: Nat) -> Bool {
        a = 0 or exists(b: Nat) { a = b.suc }
    }
    Nat.induction(f)
}

theorem lte_cancel_suc(a: Nat, b: Nat) { a.suc <= b.suc -> a <= b } by {
    let c: Nat satisfy { a.suc + c = b.suc }
    a.suc + c = b.suc
    (a + c).suc = b.suc
    a + c = b
    a <= b
}

theorem lt_cancel_suc(a: Nat, b: Nat) {
    a.suc < b.suc -> a < b
} by {
    a.suc <= b.suc
    b.suc != a.suc
    a <= b and b != a
}

theorem lt_not_symm(a: Nat, b: Nat) { a < b -> not b < a } by {
    define f(x: Nat) -> Bool {
        forall(y: Nat) { lt_not_symm(x, y) }
    }
    Nat.induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            forall(y: Nat) {
                if x.suc < y {
                    y != 0
                    zero_or_suc(y)
                    y = 0 or exists(z: Nat) { y = z.suc }
                    let (z: Nat) satisfy { y = z.suc }
                    x.suc < z.suc
                    x < z
                    lt_not_symm(x, z)
                    not z < x
                    not (z.suc < x.suc)
                    not (y < x.suc)
                }
                lt_not_symm(x.suc, y)
            }
            f(x.suc)
        }
    }
    f(a)
}

theorem lt_diff(a: Nat, b: Nat) {
    a < b -> exists(c: Nat) { a + c = b and c != 0 }
} by {
    a <= b
    let (c: Nat) satisfy { a + c = b }
    b != a
    c != 0
}

theorem lte_trans(a: Nat, b: Nat, c: Nat) { a <= b and b <= c -> a <= c } by {
    define f(z: Nat) -> Bool {
        forall(x: Nat, y: Nat) { lte_trans(x, y, z) }
    }
    Nat.induction(f)
    forall(x: Nat, y: Nat) {
        if x <= y and y <= 0 {
            y = 0
            x <= 0
        }
        lte_trans(x, y, 0)
    }
    f(0)
    forall(z: Nat) {
        if f(z) {
            forall(x: Nat, y: Nat) {
                if x <= y and y <= z.suc {
                    let (d: Nat) satisfy { x + d = y }
                    let (e: Nat) satisfy { y + e = z.suc }
                    x + (d + e) = z.suc
                    x <= z.suc
                }
                lte_trans(x, y, z.suc)
            }
            f(z.suc)
        }
    }
}

theorem lt_and_lte(a: Nat, b: Nat, c: Nat) { a < b and b <= c -> a < c } by {
    a <= b
    a <= c
    if a = c {
        c < b
        false
    }
    a < c
}

theorem lte_and_lt(a: Nat, b: Nat, c: Nat) { a <= b and b < c -> a < c } by {
    b <= c
    a <= c
    if a = c {
        b < a
        false
    }
    a < c
}

theorem lt_trans(a: Nat, b: Nat, c: Nat) { a < b and b < c -> a < c } by {
    a <= b
}

theorem add_cancels_left(a: Nat, b: Nat, c: Nat) { a + b = a + c -> b = c } by {
    define f(x: Nat) -> Bool { add_cancels_left(x, b, c) }
    Nat.induction(f)
    if not add_cancels_left(0, b, c) {
        0 + c = 0 + b
        not add_cancels_left(0, b, 0 + c)
        false
    }
    f(0)
    forall(x: Nat) {
        if f(x) {
            if x.suc + b = x.suc + c {
                (x + c).suc = x.suc + b
                (x + b).suc = (x + c).suc
                x + b = x + c
                b = c
            }
            x.suc + b = x.suc + c -> b = c
            if not add_cancels_left(x.suc, b, c) {
                x.suc + c = x.suc + b
                c != b
                false
            }
            f(x.suc)
        }
    }
    f(a)
}

theorem add_cancels_right(a: Nat, b: Nat, c: Nat) { b + a = c + a -> b = c } by {
    a + b = a + c
    b = c
}

theorem add_identity_right(a: Nat, b: Nat) {
    a + b = a -> b = 0
}

theorem lt_add_suc(a: Nat, b: Nat) { a < a + b.suc } by {
    a <= a + b.suc
    if a = a + b.suc {
        a + 0 = a + b.suc
        0 = b.suc
        false
    }
}

theorem lt_suc(a: Nat) { a < a.suc } by {
    a.suc = a + 1
    a.suc = a + 0.suc
}

theorem lt_suc_left(a: Nat, b: Nat) { a < b -> a.suc = b or a.suc < b } by {
    let (c: Nat) satisfy { a + c = b and c != 0 }
    let (d: Nat) satisfy { d.suc = c }
    if d = 0 {
        a + 1 = b
        a.suc = b
    } else {
        (a + d).suc = b
        a.suc + d = b
        a.suc != b
        a.suc < b
    }
}

theorem lt_suc_right(a: Nat, b: Nat) { a < b.suc -> a = b or a < b } by {
    if a != b {
        b.suc != a.suc
        a.suc < b.suc
        a < b
    }
}

theorem lt_add_left(a: Nat, b: Nat, c: Nat) { b < c -> a + b < a + c } by {
    let (d: Nat) satisfy { b + d = c }
    c != b
    d != 0
    a + b + d = a + c
    a + b < a + b + d
    a + b < a + c
}

theorem trichotomy(a: Nat, b: Nat) { a < b or b < a or a = b } by {
    define f(x: Nat) -> Bool { trichotomy(a, x) }
    Nat.induction(f)
    0 <= a
    trichotomy(a, 0)
    f(0)
    forall(x: Nat) {
        if f(x) {
            a < x or x < a or a = x
            if a < x {
                x <= x.suc
                a < x.suc
                f(x.suc)
            }
            if x < a {
                x.suc = a or x.suc < a
                if x.suc = a {
                    f(x.suc)
                } else {
                    f(x.suc)
                }
            }
            if a = x {
                a < x.suc
                f(x.suc)
            }
            f(x.suc)
        }
    }
}

theorem lt_or_lte(a: Nat, b: Nat) { a < b or b <= a } by {
    if not (a < b) and not (b <= a) {
        b = a
        false
    }
}

theorem lt_imp_lte_suc(a: Nat, b: Nat) { a < b -> a.suc <= b } by {
    if not (a.suc <= b) {
        a.suc = b
        false
    }
}

theorem lte_imp_not_lt(a: Nat, b: Nat) { a <= b -> not (b < a) } by {
    if a = b {
        not (b < a)
    } else {
        a < b
        not (b < a)
    }
}

theorem division_theorem(m: Nat, n: Nat) {
    0 < n -> exists(q: Nat, r: Nat) {
        r < n and m = q * n + r
    }
} by {
    define f(x: Nat) -> Bool { division_theorem(x, n) }
    Nat.induction(f)
    let (k0: Nat) satisfy { k0 * n = 0 }
    f(0)
    forall(x: Nat) {
        if f(x) {
            division_theorem(x, n)
            let (q: Nat, r: Nat) satisfy {
                r < n and x = q * n + r
            }
            if r.suc = n {
                x.suc = (q * n + r).suc
                x.suc = q * n + r.suc
                x.suc = q * n + n
                n + q * n = x.suc
                x.suc = q.suc * n
                x.suc = q.suc * n + 0
                f(x.suc)
            } else {
                r.suc < n
                x.suc = q * n + r.suc
                f(x.suc)
            }
            f(x.suc)
        }
    }
    division_theorem(m, n)
}

define is_composite(a: Nat) -> Bool {
    exists(b: Nat, c: Nat) {
        1 < b and 1 < c and a = b * c
    }
}

theorem mul_to_zero(a: Nat, b: Nat) { a * b = 0 -> a = 0 or b = 0 } by {
    if a != 0 and b != 0 {
        let (pred_a: Nat) satisfy { pred_a.suc = a }
        pred_a.suc * b = 0
        b + pred_a * b = 0
        false
    }
}

theorem divisor_lt(a: Nat, b: Nat, c: Nat) {
    a != 0 and 1 < b and a * b = c -> a < c
} by {
    let (d: Nat) satisfy { 1 + d = b and d != 0 }
    a * (1 + d) = c
    1 + d = d.suc
    a * d.suc = c
    a + a * d = c
    a * d != 0
    a != c
}

define is_prime(a: Nat) -> Bool {
    1 < a and not is_composite(a)
}

define divides(a: Nat, b: Nat) -> Bool {
    exists(c: Nat) { a * c = b }
}

theorem divides_self(a: Nat) { divides(a, a) }

define true_below(f: Nat -> Bool, n: Nat) -> Bool {
    forall(x: Nat) { x < n -> f(x) }
}

theorem strong_induction(f: Nat -> Bool) {
    forall(k: Nat) {
        true_below(f, k) -> f(k)
    } -> forall(n: Nat) { f(n) }
} by {
    define g(x: Nat) -> Bool {
        true_below(f, x)
    }
    Nat.induction(g)
    g(0)
    forall(x: Nat) {
        if g(x) {
            true_below(f, x)
            f(x)
            forall(y: Nat) {
                if y < x.suc {
                    if y < x {
                        f(y)
                    }
                    if not (y < x) {
                        y = x
                        f(y)
                    }
                    f(y)
                }
            }
            true_below(f, x.suc)
            g(x.suc)
        }
    }
    forall(x: Nat) {
        g(x)
    }
    forall(n: Nat) {
        g(n.suc)
        true_below(f, n.suc)
        f(n)
    }
}

theorem divides_trans(a: Nat, b: Nat, c: Nat) {
    divides(a, b) and divides(b, c) -> divides(a, c)
} by {
    let (d: Nat) satisfy { a * d = b }
    let (e: Nat) satisfy { b * e = c }
    a * (d * e) = c
}

theorem has_prime_divisor(n: Nat) {
    1 < n -> exists(p: Nat) {
        is_prime(p) and divides(p, n)
    }
} by {
    strong_induction(has_prime_divisor)
    forall(k: Nat) {
        if true_below(has_prime_divisor, k) {
            if is_prime(k) {
                divides(k, k)
                has_prime_divisor(k)
            }
            if is_composite(k) {
                let (b: Nat, c: Nat) satisfy {
                    1 < b and 1 < c and k = b * c
                }
                b != 0
                1 < c
                b * c = k
                b < k
                has_prime_divisor(b)
                let (p: Nat) satisfy {
                    is_prime(p) and divides(p, b)
                }
                divides(p, k)
                has_prime_divisor(k)
            }
            has_prime_divisor(k)
        }
    }
}

structure NatPair {
    first: Nat
    second: Nat
}

// Takes (n, n!) -> (n+1, (n+1)!)
define fac_helper(p: NatPair) -> NatPair {
    NatPair.new(p.first.suc, p.first.suc * p.second)
}

// Seems like a shame this isn't proven automatically.
// Every step in the proof is a pretty simple rewrite.
// Really, all the statements about factorials seem like they should be provable automatically.
theorem fac_helper_alt(a: Nat, b: Nat) { fac_helper(NatPair.new(a, b)) = NatPair.new(a.suc, a.suc * b) } by {
    let p: NatPair = NatPair.new(a, b)
    p.first = a
    p.second = b
    fac_helper(p) = NatPair.new(p.first.suc, p.first.suc * p.second)
    fac_helper(p) = NatPair.new(p.first.suc, a.suc * b)
}

// Takes n -> (n, n!)
define fac_pair(n: Nat) -> NatPair {
    repeat(fac_helper, NatPair.new(0, 1), n)
}

theorem fac_pair_first(n: Nat) { fac_pair(n).first = n } by {
    Nat.induction(fac_pair_first)
    repeat(fac_helper, NatPair.new(0, 1), 0).first = 0
    fac_pair(0).first = 0
    fac_pair_first(0)
    forall(x: Nat) {
        if fac_pair_first(x) {
            x = fac_pair(x).first
            let a: Nat = fac_pair(x).second
            NatPair.new(fac_pair(x).first, a) = fac_pair(x)
            fac_pair(x) = NatPair.new(x, a)
            fac_pair(x.suc) = fac_helper(fac_pair(x))
            fac_pair(x.suc) = NatPair.new(x.suc, x.suc * a)
            let b: Nat = x.suc * a
            fac_pair(x.suc) = NatPair.new(x.suc, b)
            NatPair.new(x.suc, b).first = x.suc
            fac_pair(x.suc).first = x.suc
            fac_pair_first(x.suc)
        }
    }
}

define factorial(n: Nat) -> Nat {
    fac_pair(n).second
}

theorem factorial_zero { factorial(0) = 1 } by {
    repeat(fac_helper, NatPair.new(0, 1), 0).second = 1
    fac_pair(0).second = 1
}

theorem factorial_one { factorial(1) = 1 } by {
    fac_pair(0) = NatPair.new(0, 1)
    fac_pair(1) = fac_helper(fac_pair(0))
    fac_pair(1) = NatPair.new(1, 1 * 1)
    fac_pair(1) = NatPair.new(1, 1)
}

theorem factorial_step(n: Nat) { factorial(n.suc) = n.suc * factorial(n) } by {
    fac_pair(n) = NatPair.new(n, factorial(n))
    fac_pair(n.suc) = fac_helper(fac_pair(n))

    fac_pair(n.suc) = NatPair.new(n.suc, n.suc * factorial(n))
    fac_pair(n.suc).second = n.suc * factorial(n)
}

theorem divides_factorial(k: Nat, n: Nat) {
    k != 0 and k <= n -> divides(k, factorial(n))
} by {
    define f(x: Nat) -> Bool {
        divides_factorial(k, x)
    }
    Nat.induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            k <= x -> divides(k, factorial(x))
            if k <= x.suc {
                if k = x.suc {
                    divides(x.suc, factorial(x.suc))
                    divides(k, factorial(x.suc))
                }
                if k != x.suc {
                    k.suc <= x.suc
                    k <= x
                    divides(k, factorial(x))
                    divides(factorial(x), x.suc * factorial(x))
                    divides(factorial(x), factorial(x.suc))
                    divides(k, factorial(x.suc))
                }
                divides_factorial(k, x.suc)
            }
            f(x.suc)
        }
    }
}

theorem factorial_nondecreasing(n: Nat) { factorial(n) <= factorial(n.suc) } by {
    factorial(n) <= n.suc * factorial(n)
}

theorem lte_one_factorial(a: Nat) { 1 <= factorial(a) } by {
    Nat.induction(lte_one_factorial)
    lte_one_factorial(0)
    forall(x: Nat) {
        if lte_one_factorial(x) {
            1 <= factorial(x)
            factorial(x) <= factorial(x.suc)
            1 <= factorial(x.suc)
            lte_one_factorial(x.suc)
        }
    }
}

theorem lt_imp_lt_suc(a: Nat, b: Nat) { a < b -> a < b.suc } by {
    let (c: Nat) satisfy { a + c = b and c != 0 }
    a + c.suc = b.suc
    c.suc != 0
}

theorem lte_mul_both(a: Nat, b: Nat, c: Nat) { b <= c -> a * b <= a * c } by {
    let (d: Nat) satisfy { b + d = c }
    a * (b + d) = a * c
    a * b + a * d = a * c
    a * b <= a * c
}

theorem lt_mul_both(a: Nat, b: Nat, c: Nat) { a != 0 and b < c -> a * b < a * c } by {
    let (d: Nat) satisfy { b + d = c }
    c != b
    d != 0
    a * (b + d) = a * c
    a * b + a * d = a * c
    a * d != 0
    if a * b = a * c {
        a * b + a * d = a * b
        let y: Nat = a * b
        let z: Nat = a * d
        y + z = y
        false
    }
    a * b <= a * c
    a * b < a * c
}

theorem lt_cancel_mul(a: Nat, b: Nat, c: Nat) { a != 0 and a * b < a * c -> b < c } by {
    if c <= b {
        a * c <= a * b
        false
    }
    c != b
}

theorem mul_to_one(a: Nat, b: Nat) { a * b = 1 -> a = 1 } by {
    1 != 0
    a != 0
    not (a < 1)
    b != 0
    if 1 < a {
        b * 1 < b * a
        b * 1 < a * b
        b * 1 < 1
        b * 1 = 0
        b = 0
        false
    }
}

theorem divides_suc(a: Nat, b: Nat) { divides(a, b) and divides(a, b.suc) -> a = 1 } by {
    let (k0: Nat) satisfy { a * k0 = b.suc }
    a != 0
    let (c: Nat) satisfy { a * c = b }
    let (d: Nat) satisfy { a * d = b.suc }
    a * c < a * d
    c <= d
    let (e: Nat) satisfy { c + e = d }
    a * (c + e) = b.suc
    a * c + a * e = b.suc
    b + a * e = b.suc
    b + a * e = b + 1
    a * e = 1
}

theorem exists_infinite_primes(n: Nat) {
    exists(p: Nat) {
        n < p and is_prime(p)
    }
} by {
    let m: Nat = factorial(n).suc
    if not (1 < factorial(n).suc) {
        not (1 < factorial(n))
        factorial(n) = 1
        false
    }
    1 < m
    let (p: Nat) satisfy {
        is_prime(p) and divides(p, m)
    }
    p != 1
    if p <= n {
        divides_factorial(p, n)
        divides(p, factorial(n))
        false
    }
    not (p <= n)
    n < p
}

theorem divides_zero(a: Nat) { divides(a, 0) }

theorem zero_divides(a: Nat) { divides(0, a) -> a = 0 }

theorem divides_mul(a: Nat, b: Nat, d: Nat) { divides(d, a) -> divides(d, a * b) } by {
    let (q: Nat) satisfy { q * d = a }
    q * d * b = a * b
    d * q * b = a * b
    d * (q * b) = a * b
}

theorem lte_mul(a: Nat, b: Nat) { b != 0 -> a <= a * b } by {
    not (b < 1)
    1 <= b
    a * 1 <= a * b
}

theorem divides_lte(a: Nat, b: Nat) { divides(a, b) -> b = 0 or a <= b } by {
    if b != 0 {
        let (q: Nat) satisfy { q * a = b }
        if q = 0 {
            b = 0
            false
        }
        a <= a * q
        a <= q * a
        a <= b
    }
}

theorem divides_add(a: Nat, b: Nat, d: Nat) {
    divides(d, a) and divides(d, b) -> divides(d, a + b)
} by {
    let (qa: Nat) satisfy { qa * d = a }
    let (qb: Nat) satisfy { qb * d = b }
    (qa + qb) * d = qa * d + b
    (qa + qb) * d = a + b
    divides(d, (qa + qb) * d)
}


theorem divides_symm(a: Nat, b: Nat) { divides(a, b) and divides(b, a) -> a = b } by {
    if a = 0 {
        divides(0, b)
        b = 0
        a = b
    } else {
        b != 0
        a <= b
        b <= a
        if a != b {
            a < b
            b < a
            false
        }
        a = b
    }
}

theorem cross_sum_lte(a: Nat, b: Nat, c: Nat, d: Nat) { a + b = c + d and a <= c -> d <= b } by {
    let (e: Nat) satisfy { a + e = c }
    a + b = a + e + d
    a + b = a + (e + d)
    b = e + d
    d <= b
}

// This is a "bounded" version of subtraction that returns 0 instead of negative numbers.
let bounded_sub(a: Nat, b: Nat) -> d: Nat satisfy {
    if a < b {
        d = 0
    } else {
        d + b = a
    }
} by {
    if a < b {
        0 = 0
    } else {
        b <= a
        let d: Nat satisfy { d + b = a }
    }
}

class Nat {
    define sub(self, b: Nat) -> Nat { bounded_sub(self, b) }
}

theorem sub_lt(a: Nat, b: Nat) { a < b -> a - b = 0 }

theorem add_sub(a: Nat, b: Nat) { b <= a -> a - b + b = a }

theorem sub_add(a: Nat, b: Nat) { (a + b) - b = a } by {
    b <= a + b
    ((a + b) - b) + b = a + b
}

theorem sub_self(a: Nat) { a - a = 0 }

theorem sub_zero(a: Nat) { a - 0 = a }

theorem add_imp_sub(a: Nat, b: Nat, c: Nat) { a + b = c -> c - b = a }

let mod(a: Nat, m: Nat) -> r: Nat satisfy {
    if m != 0 {
        r < m and exists(q: Nat) { q * m + r = a }
    } else {
        // It doesn't really matter how we define "mod 0".
        // We pick a mod 0 = a.
        r = a
    }
} by {
    if m != 0 {
        0 < m
    } else {
        a = a
    }
}

theorem add_mod(a: Nat, m: Nat) {
    exists(q: Nat) { q * m + mod(a, m) = a }
} by {
    if m = 0 {
        mod(a, 0) = a
        0 * 0 = 0
        0 * 0 + mod(a, 0) = a
        let (q: Nat) satisfy { q * m + mod(a, m) = a }
    } else {
        let (q: Nat) satisfy { q * m + mod(a, m) = a }
    }
}

theorem mod_by_zero(a: Nat) { mod(a, 0) = a }

theorem mod_of_zero(m: Nat) { mod(0, m) = 0 }

theorem mod_lte(a: Nat, m: Nat) {
    mod(a, m) <= a
} by {
    if m = 0 {
        mod(a, m) <= a
    } else {
        let q: Nat satisfy { q * m + mod(a, m) = a }
        mod(a, m) <= a
    }
}

theorem div_sub_mod(a: Nat, m: Nat) { divides(m, a - mod(a, m)) } by {
    let (q: Nat) satisfy { q * m + mod(a, m) = a }
    a - mod(a, m) = q * m
    divides(m, q * m)
}

theorem sub_left_distrib(a: Nat, b: Nat, c: Nat) {
    a * (b - c) = a * b - a * c
} by {
    if a = 0 {
        a * (b - c) = a * b - a * c
        sub_left_distrib(a, b, c)
    } else {
        if b < c {
            a * b < a * c
            a * b - a * c = 0
            b - c = 0
            a * (b - c) = a * b - a * c
            sub_left_distrib(a, b, c)
        }
        if not (b < c) {
            b - c + c = b
            a * (b - c) = a * b - a * c
            sub_left_distrib(a, b, c)
        }
        sub_left_distrib(a, b, c)
    }
    sub_left_distrib(a, b, c)
}

theorem sub_right_distrib(a: Nat, b: Nat, c: Nat) {
    (a - b) * c = a * c - b * c
} by {
    (a - b) * c = c * a - c * b
    (a - b) * c = a * c - c * b
}

theorem divides_sub(a: Nat, b: Nat, d: Nat) {
    divides(d, a) and divides(d, b) -> divides(d, a - b)
} by {
    let qa: Nat satisfy { qa * d = a }
    let qb: Nat satisfy { qb * d = b }
    a - b = qa * d - qb * d
    a - b = (qa - qb) * d
    divides(d, (qa - qb) * d)
    divides(d, a - b)
}

theorem divides_mod(a: Nat, m: Nat, d: Nat) {
    divides(d, a) and divides(d, m) -> divides(d, mod(a, m))
} by {
    let (q: Nat) satisfy { q * m + mod(a, m) = a }
    mod(a, m) + q * m = a
    mod(a, m) = a - q * m
    divides(d, q * m)
    divides(d, a - q * m)
    divides(d, mod(a, m))
}

theorem div_imp_mod(a: Nat, m: Nat) { divides(m, a) -> mod(a, m) = 0 } by {
    if m != 0 {
        divides(m, m)
        divides(m, mod(a, m))
        mod(a, m) < m
        not (m <= mod(a, m))
        mod(a, m) = 0
    } else {
        a = 0
        mod(a, m) = 0
    }
    mod(a, m) = 0
}

theorem small_mod(a: Nat, m: Nat) { a < m -> mod(a, m) = a } by {
    let (q: Nat) satisfy { q * m + mod(a, m) = a }
    if q = 0 {
        0 + mod(a, m) = a
        mod(a, m) = a
    } else {
        m != 0
        q * m != 0
        divides(m, q * m)
        m <= q * m
        m <= a
        false
    }
    mod(a, m) = a
}

theorem mod_mod(a: Nat, m: Nat) { mod(mod(a, m), m) = mod(a, m) } by {
    if m != 0 {
        mod(a, m) < m
        mod(mod(a, m), m) = mod(a, m)
        mod_mod(a, m)
    } else {
        mod(mod(a, m), m) = mod(a, m)
        mod_mod(a, m)
    }
}

theorem mod_mul(m: Nat, q: Nat) { mod(q * m, m) = 0 } by {
    divides(m, q * m)
}

theorem divides_add_copy(a: Nat, b: Nat, d: Nat) {
    divides(d, a) and divides(d, b) -> divides(d, a + b)
}

theorem divides_unmod(d: Nat, a: Nat, m: Nat) {
    divides(d, m) and divides(d, mod(a, m)) -> divides(d, a)
} by {
    let (q: Nat) satisfy { q * m + mod(a, m) = a }
    divides(m, q * m)
    divides(d, q * m)
    divides(d, q * m + mod(a, m))
    divides(d, a)
    if not divides_unmod(d, a, m) {
        divides(d, m)
        divides(d, mod(a, m))
        false
    }
}