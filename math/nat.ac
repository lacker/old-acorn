// The axioms of Peano arithmetic.
// Contains enough detail that we can prove these with "check".

type Nat: axiom

define 0: Nat = axiom

define Suc: Nat -> Nat = axiom
define 1: Nat = Suc(0)

axiom suc_injective(x: Nat, y: Nat): Suc(x) = Suc(y) -> x = y

axiom suc_neq_zero(x: Nat): Suc(x) != 0

axiom induction(f: Nat -> bool): f(0) & forall(k: Nat) { f(k) -> f(Suc(k)) } -> forall(n: Nat) { f(n) }

// Ideally a and f would be templated rather than just Nat.
define recursion(f: Nat -> Nat, a: Nat, n: Nat) -> Nat = axiom
axiom recursion_base(f: Nat -> Nat, a: Nat): recursion(f, a, 0) = a
axiom recursion_step(f: Nat -> Nat, a: Nat, n: Nat): recursion(f, a, Suc(n)) = f(recursion(f, a, n))

define add(a: Nat, b: Nat) -> Nat = recursion(Suc, a, b)

// Now let's have some theorems.

theorem add_zero_right(a: Nat): add(a, 0) = a

define 2: Nat = Suc(1)

theorem one_plus_one: add(1, 1) = 2

theorem add_zero_left(a: Nat): add(0, a) = a

theorem add_suc_right(a: Nat, b: Nat): add(a, Suc(b)) = Suc(add(a, b))

theorem add_suc_left(a: Nat, b: Nat): add(Suc(a), b) = Suc(add(a, b))

theorem suc_ne(a: Nat): Suc(a) != a by {
    induction(suc_ne)
}

theorem suc_suc_ne(a: Nat): Suc(Suc(a)) != a

theorem add_comm(a: Nat, b: Nat): add(a, b) = add(b, a)

theorem add_assoc(a: Nat, bb: Nat, cc: Nat): add(add(a, bb), cc) = add(a, add(bb, cc)) by {
    let f(x: Nat) -> bool = add_assoc(x, bb, cc) 
    induction(f)
    forall(x: Nat) {
        if f(x) {
            add(add(Suc(x), bb), cc) = add(Suc(add(x, bb)), cc)
            add(add(Suc(x), bb), cc) = Suc(add(add(x, bb), cc))
            Suc(add(add(x, bb), cc)) = Suc(add(x, add(bb, cc)))
            add(add(Suc(x), bb), cc) = Suc(add(x, add(bb, cc)))
            add(add(Suc(x), bb), cc) = add(Suc(x), add(bb, cc))
            f(Suc(x))
        }
    }
    f(0)
    f(a)
}

define adder(a: Nat): Nat -> Nat = function(b: Nat) { add(a, b) }

define mul(a: Nat, b: Nat) -> Nat = recursion(adder(a), 0, b)