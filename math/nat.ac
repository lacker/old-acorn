// The axioms of Peano arithmetic.
// Contains enough detail that we can prove these with "check".

type Nat: axiom

let 0: Nat = axiom

let suc: Nat -> Nat = axiom
let 1: Nat = suc(0)

axiom suc_injective(x: Nat, y: Nat): suc(x) = suc(y) -> x = y

axiom suc_neq_zero(x: Nat): suc(x) != 0

axiom induction(f: Nat -> Bool):
    f(0) & forall(k: Nat) { f(k) -> f(suc(k)) } -> forall(n: Nat) { f(n) }

define recursion<T>(f: T -> T, a: T, n: Nat) -> T: axiom
axiom recursion_base<T>(f: T -> T, a: T): recursion(f, a, 0) = a
axiom recursion_step<T>(f: T -> T, a: T, n: Nat): recursion(f, a, suc(n)) = f(recursion(f, a, n))

class Nat {
    define add(self: Nat, b: Nat) -> Nat: recursion(suc, self, b)
}

// Now let's have some theorems.

theorem add_zero_right(a: Nat): a + 0 = a

let 2: Nat = suc(1)

theorem one_plus_one: 1 + 1 = 2 by {
    suc(recursion(suc, 1, 0)) = 2
    1 + suc(0) = 2
}

theorem add_zero_left(a: Nat): 0 + a = a by {
    induction(add_zero_left)
    0 + 0 = 0
    add_zero_left(0)
    forall(x: Nat) {
        if add_zero_left(x) {
            0 + x = x
            0 + suc(x) = suc(x)
            add_zero_left(suc(x))
        }
    }
}

theorem add_suc_right(a: Nat, b: Nat): a + suc(b) = suc(a + b)

theorem add_suc_left(a: Nat, b: Nat): suc(a) + b = suc(a + b) by {
    define f(x: Nat) -> Bool: add_suc_left(a, x)
    induction(f)
    add_suc_left(a, 0)
    f(0)
    forall(x: Nat) {
        if f(x) {
            add_suc_left(a, suc(x))
            f(suc(x))
        }
    }
}

theorem add_one_right(a: Nat): a + 1 = suc(a)

theorem add_one_left(a: Nat): 1 + a = suc(a)

theorem suc_ne(a: Nat): suc(a) != a by {
    induction(suc_ne)
    suc_ne(0)
    forall(x: Nat) {
        if suc_ne(x) {
            suc(x) != x
            suc(suc(x)) != suc(x)
            suc_ne(suc(x))
        }
    }
}

theorem suc_suc_ne(a: Nat): suc(suc(a)) != a by {
    induction(suc_suc_ne)
    suc_suc_ne(0)
    forall(x: Nat) {
        if suc_suc_ne(x) {
            suc_suc_ne(suc(x))
        }
    }
}

theorem add_comm(a: Nat, b: Nat): a + b = b + a by {
    define f(x: Nat) -> Bool: add_comm(x, b)
    induction(f)
    add_comm(0, b)
    f(0)
    forall(x: Nat) {
        if f(x) {
            b + suc(x) = suc(x + b)
            f(suc(x))
        }
    }
}

theorem add_assoc(a: Nat, b: Nat, c: Nat): a + b + c = a + (b + c) by {
    define f(x: Nat) -> Bool: add_assoc(x, b, c) 
    induction(f)
    forall(x: Nat) {
        if f(x) {
            suc(x) + b + c = suc(x + b + c)
            suc(x) + b + c = suc(x) + (b + c)
            f(suc(x))
        }
    }
    f(0)
}

define adder(a: Nat) -> (Nat -> Nat): function(b: Nat) { a + b }

define mul(a: Nat, b: Nat) -> Nat: recursion(adder(a), 0, b)

theorem mul_zero_right(a: Nat): mul(a, 0) = 0

theorem mul_zero_left(a: Nat): mul(0, a) = 0 by {
    induction(mul_zero_left)
    mul_zero_left(0)
    forall(x: Nat) {
        if mul_zero_left(x) {
            adder(0, mul(0, x)) = 0
            mul_zero_left(suc(x))
        }
    }
}

theorem mul_suc_right(a: Nat, b: Nat): mul(a, suc(b)) = a + mul(a, b)

theorem mul_suc_left(a: Nat, b: Nat): mul(suc(a), b) = b + mul(a, b) by {
    define f(x: Nat) -> Bool: mul_suc_left(a, x)
    induction(f)
    0 + mul(a, 0) = 0
    f(0)
    forall(x: Nat) {
        if f(x) {
            mul(suc(a), x) = x + mul(a, x)
            mul(suc(a), suc(x)) = suc(a) + mul(suc(a), x)
            mul(suc(a), suc(x)) = suc(a) + (x + mul(a, x))
            mul(a, suc(x)) = a + mul(a, x)
            suc(a) + (x + mul(a, x)) = suc(a) + x + mul(a, x)
            suc(a) + (x + mul(a, x)) = suc(a + x) + mul(a, x)
            suc(a) + (x + mul(a, x)) = suc(x + a) + mul(a, x)
            suc(a) + (x + mul(a, x)) = suc(x) + a + mul(a, x)
            add_assoc(suc(x), a, mul(a, x))
            suc(x) + a + mul(a, x) = suc(x) + (a + mul(a, x))
            suc(a) + (x + mul(a, x)) = suc(x) + (a + mul(a, x))
            mul(suc(a), suc(x)) = suc(x) + (a + mul(a, x))
            mul(suc(a), suc(x)) = suc(x) + mul(a, suc(x))
            f(suc(x))
        }
    }
    f(b)
}

theorem mul_one_one: mul(1, 1) = 1 by {
    mul(1, 1) = mul(1, suc(0))
    mul(1, 1) = 1 + mul(1, 0)
    mul(1, 1) = 1 + 0
    mul(1, 1) = 1
}

theorem mul_comm(a: Nat, b: Nat): mul(a, b) = mul(b, a) by {
    define f(x: Nat) -> Bool: mul_comm(x, b)
    induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            mul(x, b) = mul(b, x)
            mul(suc(x), b) = b + mul(x, b)
            mul(b, suc(x)) = b + mul(x, b)
            mul(suc(x), b) = mul(b, suc(x))
            f(suc(x))
        }
    }
    f(a)
}

theorem add_comm_4(a: Nat, b: Nat, c: Nat, d: Nat):
    (a + b) + (c + d) = (a + c) + (b + d) by {
    a + (b + c) = a + c + b
}

theorem distrib_left(a: Nat, b: Nat, c: Nat):
    mul(a, b + c) = mul(a, b) + mul(a, c) by {
    define f(x: Nat) -> Bool: distrib_left(x, b, c)
    induction(f)
    mul(0, b) + 0 = 0
    distrib_left(0, b, c)
    f(0)
    forall(x: Nat) {
        if f(x) {
            mul(x, b + c) = mul(x, b) + mul(x, c)
            mul(suc(x), b + c) = b + c + mul(x, b + c)
            mul(suc(x), b + c) = b + c + (mul(x, b) + mul(x, c))
            mul(suc(x), b + c) = (b + mul(x, b)) + (c + mul(x, c))
            b + mul(x, b) = mul(suc(x), b)
            c + mul(x, c) = mul(suc(x), c)
            (b + mul(x, b)) + (c + mul(x, c)) = mul(suc(x), b) + (c + mul(x, c))
            (b + mul(x, b)) + (c + mul(x, c)) = mul(suc(x), b) + mul(suc(x), c)
            mul(suc(x), b + c) = mul(suc(x), b) + mul(suc(x), c)
            distrib_left(suc(x), b, c)
            f(suc(x))
        }
    }
}

theorem distrib_right(a: Nat, b: Nat, c: Nat):
    mul(a + b, c) = mul(a, c) + mul(b, c) by {
    mul(c, a) + mul(b, c) = mul(c, a + b)
}

theorem mul_assoc(a: Nat, b: Nat, c: Nat): mul(mul(a, b), c) = mul(a, mul(b, c)) by {
    define f(x: Nat) -> Bool: mul_assoc(x, b, c)
    induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            mul(mul(x, b), c) = mul(x, mul(b, c))
            mul(mul(suc(x), b), c) = mul(b + mul(x, b), c)
            mul(b + mul(x, b), c) = mul(b, c) + mul(mul(x, b), c)
            mul(mul(suc(x), b), c) = mul(b, c) + mul(mul(x, b), c)
            mul(mul(suc(x), b), c) = mul(b, c) + mul(x, mul(b, c))
            mul(mul(suc(x), b), c) = mul(suc(x), mul(b, c))
            f(suc(x))
        }
    }
}

theorem mul_one_right(a: Nat): mul(a, 1) = a by {
    a + mul(a, 0) = a
}

theorem mul_one_left(a: Nat): mul(1, a) = a

// Comparisons


define lte(a: Nat, b: Nat) -> Bool: exists(c: Nat) { a + c = b }

define lt(a: Nat, b: Nat) -> Bool: lte(a, b) & a != b

theorem lt_not_ref(a: Nat): !lt(a, a)

theorem lte_ref(a: Nat): lte(a, a)

theorem add_to_zero(a: Nat, b: Nat): a + b = 0 -> a = 0 & b = 0 by {
    define f(x: Nat) -> Bool: add_to_zero(x, b)
    induction(f)
    f(0)
    forall(x: Nat) {
        add_to_zero(suc(x), b)
        f(suc(x))
    }
}

theorem only_zero_lte_zero(a: Nat): lte(a, 0) -> a = 0

theorem not_lt_zero(a: Nat): !lt(a, 0)

theorem zero_or_suc(a: Nat): a = 0 | exists(b: Nat) { a = suc(b) } by {
    define f(x: Nat) -> Bool: a = 0 | exists(b: Nat) { a = suc(b) }
    induction(f)
}

theorem lte_cancel_suc(a: Nat, b: Nat): lte(suc(a), suc(b)) -> lte(a, b) by {
    exists(c: Nat) { suc(a) + c = suc(b) }
    suc(a) + c = suc(b)
    suc(a + c) = suc(b)
    a + c = b
    lte(a, b)
}

theorem lt_cancel_suc(a: Nat, b: Nat): lt(suc(a), suc(b)) -> lt(a, b)

theorem lt_not_symm(a: Nat, b: Nat): lt(a, b) -> !lt(b, a) by {
    define f(x: Nat) -> Bool: forall(y: Nat) { lt_not_symm(x, y) }
    induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            forall(y: Nat) {
                if lt(suc(x), y) {
                    y != 0
                    zero_or_suc(y)
                    y = 0 | exists(z: Nat) { y = suc(z) }
                    exists(z: Nat) { y = suc(z) }
                    lt(suc(x), suc(z))
                    lt(x, z)
                    !lt(z, x)
                    !lt(suc(z), suc(x))
                    !lt(y, suc(x))
                }
            }
            f(suc(x))
        }
    }
}

theorem lt_diff(a: Nat, b: Nat): lt(a, b) -> exists(c: Nat) { a + c = b & c != 0 } by {
    exists(c: Nat) { a + c = b }
    b != a
    c != 0
}

theorem lte_trans(a: Nat, b: Nat, c: Nat): lte(a, b) & lte(b, c) -> lte(a, c) by {
    define f(z: Nat) -> Bool: forall(x: Nat, y: Nat) { lte_trans(x, y, z) }
    induction(f)
    forall(x: Nat, y: Nat) {
        lte_trans(x, y, 0)
    }
    f(0)
    forall(z: Nat) {
        if f(z) {
            forall(x: Nat, y: Nat) {
                if lte(x, y) & lte(y, suc(z)) {
                    exists(d: Nat) { x + d = y }
                    exists(e: Nat) { y + e = suc(z) }
                    x + (d + e) = suc(z)
                    lte(x, suc(z))
                }
                lte_trans(x, y, suc(z))
            }
            f(suc(z))
        }
    }
}

theorem lt_and_lte(a: Nat, b: Nat, c: Nat): lt(a, b) & lte(b, c) -> lt(a, c) by {
    lte(a, b)
    lte(a, c)
    if a = c {
        lt(c, b)
        false
    }
    lt(a, c)
}

theorem lte_and_lt(a: Nat, b: Nat, c: Nat): lte(a, b) & lt(b, c) -> lt(a, c) by {
    lte(b, c)
    lte(a, c)
    if a = c {
        lt(b, a)
        false
    }
    lt(a, c)
}

theorem lt_trans(a: Nat, b: Nat, c: Nat): lt(a, b) & lt(b, c) -> lt(a, c) by {
    lte(a, b)
}

theorem add_cancels_left(a: Nat, b: Nat, c: Nat): a + b = a + c -> b = c by {
    define f(x: Nat) -> Bool: add_cancels_left(x, b, c)
    induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            if suc(x) + b = suc(x) + c {
                suc(x + c) = suc(x) + b
                suc(x + b) = suc(x + c)
                x + b = x + c
                b = c
            }
            suc(x) + b = suc(x) + c -> b = c
            f(suc(x))
        }
    }
    f(a)
}

theorem add_cancels_right(a: Nat, b: Nat, c: Nat): b + a = c + a -> b = c by {
    a + b = a + c
    b = c
}

theorem add_identity_right(a: Nat, b: Nat): a + b = a -> b = 0

theorem lt_add_suc(a: Nat, b: Nat): lt(a, a + suc(b)) by {
    lte(a, a + suc(b))
    if a = a + suc(b) {
        a + 0 = a + suc(b)
        0 = suc(b)
        false
    }
}

theorem lt_suc(a: Nat): lt(a, suc(a)) by {
    suc(a) = a + 1
    suc(a) = a + suc(0)
}

theorem lt_suc_left(a: Nat, b: Nat): lt(a, b) -> suc(a) = b | lt(suc(a), b) by {
    exists(c: Nat) { a + c = b & c != 0 }
    exists(d: Nat) { suc(d) = c }
    if d = 0 {
        a + 1 = b
        suc(a) = b
    } else {
        suc(a + d) = b
        suc(a) + d = b
        suc(a) != b
        lt(suc(a), b)
    }
}

theorem lt_suc_right(a: Nat, b: Nat): lt(a, suc(b)) -> a = b | lt(a, b) by {
    if a != b {
        suc(b) != suc(a)
        lt(suc(a), suc(b))
        lt(a, b)
    }
}

theorem lt_add_left(a: Nat, b: Nat, c: Nat): lt(b, c) -> lt(a + b, a + c) by {
    exists(d: Nat) { b + d = c }
    c != b
    d != 0
    a + b + d = a + c
    lt(a + b, a + b + d)
    lt(a + b, a + c)
}

theorem trichotomy(a: Nat, b: Nat): lt(a, b) | lt(b, a) | a = b by {
    define f(x: Nat) -> Bool: trichotomy(a, x)
    induction(f)
    trichotomy(a, 0)
    f(0)
    forall(x: Nat) {
        if f(x) {
            lt(a, x) | lt(x, a) | a = x
            if lt(a, x) {
                lte(x, suc(x))
                lt(a, suc(x))
            }
            if lt(x, a) {
                suc(x) = a | lt(suc(x), a)
            }
            if a = x {
                lt(a, suc(x))
            }
            f(suc(x))
        }
    }
}

theorem lt_or_lte(a: Nat, b: Nat): lt(a, b) | lte(b, a) by {
    if !lt(a, b) & !lte(b, a) {
        b = a
        false
    }
}

theorem lt_imp_lte_suc(a: Nat, b: Nat): lt(a, b) -> lte(suc(a), b) by {
    if !lte(suc(a), b) {
        suc(a) = b
        false
    }
}

theorem lte_imp_not_lt(a: Nat, b: Nat): lte(a, b) -> !lt(b, a) by {
    if a = b {
        !lt(b, a)
    } else {
        lt(a, b)
        !lt(b, a)
    }
}

theorem division_theorem(m: Nat, n: Nat): lt(0, n) -> exists(q: Nat, r: Nat) {
    lt(r, n) & m = mul(q, n) + r
} by {
    define f(x: Nat) -> Bool: division_theorem(x, n)
    induction(f)
    exists(k0: Nat) { mul(k0, n) = 0 }
    f(0)
    forall(x: Nat) {
        if f(x) {
            division_theorem(x, n)
            exists(q: Nat, r: Nat) {
                lt(r, n) & x = mul(q, n) + r
            }
            if suc(r) = n {
                suc(x) = suc(mul(q, n) + r)
                suc(x) = mul(q, n) + suc(r)
                suc(x) = mul(q, n) + n
                n + mul(q, n) = suc(x)
                suc(x) = mul(suc(q), n)
                suc(x) = mul(suc(q), n) + 0
                f(suc(x))
            } else {
                lt(suc(r), n)
                suc(x) = mul(q, n) + suc(r)
                f(suc(x))
            }
            f(suc(x))
        }
    }
    division_theorem(m, n)
}

define is_composite(a: Nat) -> Bool: exists(b: Nat, c: Nat) {
    lt(1, b) & lt(1, c) & a = mul(b, c)
}

theorem mul_to_zero(a: Nat, b: Nat): mul(a, b) = 0 -> a = 0 | b = 0 by {
    if a != 0 & b != 0 {
        exists(pred_a: Nat) { suc(pred_a) = a }
        mul(suc(pred_a), b) = 0
        b + mul(pred_a, b) = 0
        false
    }
}

theorem divisor_lt(a: Nat, b: Nat, c: Nat):
    a != 0 & lt(1, b) & mul(a, b) = c -> lt(a, c) by {
    exists(d: Nat) { 1 + d = b & d != 0 }
    mul(a, 1 + d) = c
    1 + d = suc(d)
    mul(a, suc(d)) = c
    a + mul(a, d) = c
    mul(a, d) != 0
    a != c
}

define is_prime(a: Nat) -> Bool: lt(1, a) & !is_composite(a)

define divides(a: Nat, b: Nat) -> Bool: exists(c: Nat) { mul(a, c) = b }

theorem divides_self(a: Nat): divides(a, a)

define true_below(f: Nat -> Bool, n: Nat) -> Bool: forall(x: Nat) { lt(x, n) -> f(x) }

theorem strong_induction(f: Nat -> Bool): forall(k: Nat) {
    true_below(f, k) -> f(k)
} -> forall(n: Nat) { f(n) } by {
    define g(x: Nat) -> Bool: true_below(f, x)
    induction(g)
    g(0)
    forall(x: Nat) {
        if g(x) {
            true_below(f, x)
            f(x)
            forall(y: Nat) {
                if lt(y, suc(x)) {
                    if lt(y, x) {
                        f(y)
                    }
                    if !lt(y, x) {
                        y = x
                        f(y)
                    }
                    f(y)
                }
            }
            true_below(f, suc(x))
            g(suc(x))
        }
    }
    forall(x: Nat) {
        g(x)
    }
    forall(n: Nat) {
        g(suc(n))
        true_below(f, suc(n))
        f(n)
    }
}

theorem divides_trans(a: Nat, b: Nat, c: Nat):
    divides(a, b) & divides(b, c) -> divides(a, c) by {
    exists(d: Nat) { mul(a, d) = b }
    exists(e: Nat) { mul(b, e) = c }
    mul(a, mul(d, e)) = c
}

theorem has_prime_divisor(n: Nat): lt(1, n) -> exists(p: Nat) {
    is_prime(p) & divides(p, n)
} by {
    strong_induction(has_prime_divisor)
    forall(k: Nat) {
        if true_below(has_prime_divisor, k) {
            if is_prime(k) {
                divides(k, k)
                has_prime_divisor(k)
            }
            if is_composite(k) {
                exists(b: Nat, c: Nat) {
                    lt(1, b) & lt(1, c) & k = mul(b, c)
                }
                b != 0
                lt(1, c)
                mul(b, c) = k
                lt(b, k)
                has_prime_divisor(b)
                exists(p: Nat) {
                    is_prime(p) & divides(p, b)
                }
                divides(p, k)
                has_prime_divisor(k)
            }
            has_prime_divisor(k)
        }
    }
}

struct NatPair {
    first: Nat
    second: Nat
}

// Takes (n, n!) -> (n+1, (n+1)!)
define fac_helper(p: NatPair) -> NatPair: NatPair.new(suc(NatPair.first(p)), mul(suc(NatPair.first(p)), NatPair.second(p)))

// Seems like a shame this isn't proven automatically.
// Every step in the proof is a pretty simple rewrite.
// Really, all the statements about factorials seem like they should be provable automatically.
theorem fac_helper_alt(a: Nat, b: Nat): fac_helper(NatPair.new(a, b)) = NatPair.new(suc(a), mul(suc(a), b)) by {
    let p: NatPair = NatPair.new(a, b)
    NatPair.first(p) = a
    NatPair.second(p) = b
    fac_helper(p) = NatPair.new(suc(NatPair.first(p)), mul(suc(NatPair.first(p)), NatPair.second(p)))
    fac_helper(p) = NatPair.new(suc(NatPair.first(p)), mul(suc(a), b))
}

// Takes n -> (n, n!)
define fac_pair(n: Nat) -> NatPair: recursion(fac_helper, NatPair.new(0, 1), n)

theorem fac_pair_first(n: Nat): NatPair.first(fac_pair(n)) = n by {
    induction(fac_pair_first)
    fac_pair_first(0)
    forall(x: Nat) {
        if fac_pair_first(x) {
            x = NatPair.first(fac_pair(x))
            let a: Nat = NatPair.second(fac_pair(x))
            NatPair.new(NatPair.first(fac_pair(x)), a) = fac_pair(x)
            fac_pair(x) = NatPair.new(x, a)
            fac_pair(suc(x)) = fac_helper(fac_pair(x))
            fac_pair(suc(x)) = NatPair.new(suc(x), mul(suc(x), a))
            let b: Nat = mul(suc(x), a)
            fac_pair(suc(x)) = NatPair.new(suc(x), b)
            NatPair.first(NatPair.new(suc(x), b)) = suc(x)
            NatPair.first(fac_pair(suc(x))) = suc(x)
            fac_pair_first(suc(x))
        }
    }
}

define factorial(n: Nat) -> Nat: NatPair.second(fac_pair(n))

theorem factorial_zero: factorial(0) = 1

theorem factorial_one: factorial(1) = 1 by {
    fac_pair(0) = NatPair.new(0, 1)
    fac_pair(1) = fac_helper(fac_pair(0))
    fac_pair(1) = NatPair.new(1, mul(1, 1))
    fac_pair(1) = NatPair.new(1, 1)
}

theorem factorial_step(n: Nat): factorial(suc(n)) = mul(suc(n), factorial(n)) by {
    fac_pair(n) = NatPair.new(n, factorial(n))
    fac_pair(suc(n)) = fac_helper(fac_pair(n))

    fac_pair(suc(n)) = NatPair.new(suc(n), mul(suc(n), factorial(n)))
    NatPair.second(fac_pair(suc(n))) = mul(suc(n), factorial(n))
}

theorem divides_factorial(k: Nat, n: Nat):
    k != 0 & lte(k, n) -> divides(k, factorial(n)) by {
    define f(x: Nat) -> Bool: divides_factorial(k, x)
    induction(f)
    f(0)
    forall(x: Nat) {
        if f(x) {
            lte(k, x) -> divides(k, factorial(x))
            if lte(k, suc(x)) {
                if k = suc(x) {
                    divides(suc(x), factorial(suc(x)))
                    divides(k, factorial(suc(x)))
                }
                if k != suc(x) {
                    lte(suc(k), suc(x))
                    lte(k, x)
                    divides(k, factorial(x))
                    divides(factorial(x), mul(suc(x), factorial(x)))
                    divides(factorial(x), factorial(suc(x)))
                    divides(k, factorial(suc(x)))
                }
                divides_factorial(k, suc(x))
            }
            f(suc(x))
        }
    }
}

theorem factorial_nondecreasing(n: Nat): lte(factorial(n), factorial(suc(n))) by {
    lte(factorial(n), mul(suc(n), factorial(n)))
}

theorem lte_one_factorial(a: Nat): lte(1, factorial(a)) by {
    induction(lte_one_factorial)
    lte_one_factorial(0)
    forall(x: Nat) {
        if lte_one_factorial(x) {
            lte(1, factorial(x))
            lte(factorial(x), factorial(suc(x)))
            lte(1, factorial(suc(x)))
            lte_one_factorial(suc(x))
        }
    }
}

theorem lt_imp_lt_suc(a: Nat, b: Nat): lt(a, b) -> lt(a, suc(b)) by {
    exists(c: Nat) { a + c = b & c != 0 }
    a + suc(c) = suc(b)
    suc(c) != 0
}

theorem lte_mul_both(a: Nat, b: Nat, c: Nat): lte(b, c) -> lte(mul(a, b), mul(a, c)) by {
    exists(d: Nat) { b + d = c }
    mul(a, b + d) = mul(a, c)
    mul(a, b) + mul(a, d) = mul(a, c)
    lte(mul(a, b), mul(a, c))
}

theorem lt_mul_both(a: Nat, b: Nat, c: Nat): a != 0 & lt(b, c) -> lt(mul(a, b), mul(a, c)) by {
    exists(d: Nat) { b + d = c }
    c != b
    d != 0
    mul(a, b + d) = mul(a, c)
    mul(a, b) + mul(a, d) = mul(a, c)
    mul(a, d) != 0
    if mul(a, b) = mul(a, c) {
        mul(a, b) + mul(a, d) = mul(a, b)
        let y: Nat = mul(a, b)
        let z: Nat = mul(a, d)
        y + z = y
        false
    }
    lte(mul(a, b), mul(a, c))
    lt(mul(a, b), mul(a, c))
}

theorem lt_cancel_mul(a: Nat, b: Nat, c: Nat): a != 0 & lt(mul(a, b), mul(a, c)) -> lt(b, c) by {
    if lte(c, b) {
        lte(mul(a, c), mul(a, b))
        false
    }
    c != b
}

theorem mul_to_one(a: Nat, b: Nat): mul(a, b) = 1 -> a = 1 by {
    1 != 0
    a != 0
    !lt(a, 1)
    b != 0
    if lt(1, a) {
        lt(mul(b, 1), mul(b, a))
        lt(mul(b, 1), mul(a, b))
        lt(mul(b, 1), 1)
        mul(b, 1) = 0
        b = 0
        false
    }
}

theorem divides_suc(a: Nat, b: Nat): divides(a, b) & divides(a, suc(b)) -> a = 1 by {
    exists(k0: Nat) { mul(a, k0) = suc(b) }
    a != 0
    exists(c: Nat) { mul(a, c) = b }
    exists(d: Nat) { mul(a, d) = suc(b) }
    lt(mul(a, c), mul(a, d))
    lte(c, d)
    exists(e: Nat) { c + e = d }
    mul(a, c + e) = suc(b)
    mul(a, c) + mul(a, e) = suc(b)
    b + mul(a, e) = suc(b)
    b + mul(a, e) = b + 1
    mul(a, e) = 1
}

theorem exists_infinite_primes(n: Nat): exists(p: Nat) {
    lt(n, p) & is_prime(p)
} by {
    let m: Nat = suc(factorial(n))
    if !lt(1, suc(factorial(n))) {
        !lt(1, factorial(n))
        factorial(n) = 1
        false
    }
    lt(1, m)
    exists(p: Nat) {
        is_prime(p) & divides(p, m)
    }
    p != 1
    if lte(p, n) {
        divides_factorial(p, n)
        divides(p, factorial(n))
        false
    }
    !lte(p, n)
    lt(n, p)
}

theorem divides_zero(a: Nat): divides(a, 0)

theorem zero_divides(a: Nat): divides(0, a) -> a = 0

theorem divides_mul(a: Nat, b: Nat, d: Nat): divides(d, a) -> divides(d, mul(a, b)) by {
    exists(q: Nat) { mul(q, d) = a }
    mul(mul(q, d), b) = mul(a, b)
    mul(mul(d, q), b) = mul(a, b)
    mul(d, mul(q, b)) = mul(a, b)
}

theorem lte_mul(a: Nat, b: Nat): b != 0 -> lte(a, mul(a, b)) by {
    !lt(b, 1)
    lte(1, b)
    lte(mul(a, 1), mul(a, b))
}

theorem divides_lte(a: Nat, b: Nat): divides(a, b) -> b = 0 | lte(a, b) by {
    if b != 0 {
        exists(q: Nat) { mul(q, a) = b }
        if q = 0 {
            b = 0
            false
        }
        lte(a, mul(a, q))
        lte(a, mul(q, a))
        lte(a, b)
    }
}

theorem divides_add(a: Nat, b: Nat, d: Nat):
    divides(d, a) & divides(d, b) -> divides(d, a + b) by {
    exists(qa: Nat) { mul(qa, d) = a }
    exists(qb: Nat) { mul(qb, d) = b }
    mul(qa + qb, d) = mul(qa, d) + b
    mul(qa + qb, d) = a + b
    divides(d, mul(qa + qb, d))
}


theorem divides_symm(a: Nat, b: Nat): divides(a, b) & divides(b, a) -> a = b by {
    if a = 0 {
        divides(0, b)
        b = 0
        a = b
    } else {
        b != 0
        lte(a, b)
        lte(b, a)
        if a != b {
            lt(a, b)
            lt(b, a)
            false
        }
        a = b
    }
}

theorem cross_sum_lte(a: Nat, b: Nat, c: Nat, d: Nat): a + b = c + d & lte(a, c) -> lte(d, b) by {
    exists(e: Nat) { a + e = c }
    a + b = a + e + d
    a + b = a + (e + d)
    b = e + d
    lte(d, b)
}

define find<T>(f: T -> Bool) -> T: axiom

// The axiom of choice.
// It's simplest to just make this a normal axiom.
axiom choice<T>(f: T -> Bool): exists(x: T) { f(x) } -> f(find(f))

// is_sub(a, b)(x) tells you whether a - b = x.
// This is a "bounded" version of subtraction that returns 0 instead of negative numbers.
define is_sub(a: Nat, b: Nat) -> (Nat -> Bool): function(x: Nat) {
    // Defining sub(a, b) = x
    if lt(a, b) {
        x = 0
    } else {
        x + b = a
    }
}

theorem sub_def(a: Nat, b: Nat): exists(x: Nat) { is_sub(a, b)(x) } by {
    if lt(a, b) {
        is_sub(a, b)(0)
    } else {
        lte(b, a)
        exists(x: Nat) { x + b = a }
        is_sub(a, b)(x)
    }
}

define sub(a: Nat, b: Nat) -> Nat: find(is_sub(a, b))

theorem sub_is_sub(a: Nat, b: Nat): is_sub(a, b)(sub(a, b)) by {
    let f: Nat -> Bool = is_sub(a, b)
    exists(x: Nat) { is_sub(a, b)(x) }
    f(x)
    f(find(f))
    is_sub(a, b)(find(f))
    is_sub(a, b)(sub(a, b))
}

theorem sub_lt(a: Nat, b: Nat): lt(a, b) -> sub(a, b) = 0

theorem add_sub(a: Nat, b: Nat): lte(b, a) -> sub(a, b) + b = a

theorem sub_add(a: Nat, b: Nat): sub(a + b, b) = a by {
    lte(b, a + b)
    sub(a + b, b) + b = a + b
}

theorem sub_self(a: Nat): sub(a, a) = 0

theorem sub_zero(a: Nat): sub(a, 0) = a

theorem add_imp_sub(a: Nat, b: Nat, c: Nat): a + b = c -> sub(c, b) = a

// Let's define mod similarly to how we defined sub.
define is_mod(a: Nat, m: Nat) -> (Nat -> Bool): function(r: Nat) {
    if m != 0 {
        lt(r, m) & exists(q: Nat) { mul(q, m) + r = a }
    } else {
        // It doesn't really matter how we define "mod 0".
        // We pick a mod 0 = a.
        r = a
    }
}

theorem mod_def(a: Nat, m: Nat): exists(r: Nat) { is_mod(a, m)(r) } by {
    if m != 0 {
        lt(0, m)
        exists(q: Nat, r: Nat) {
            lt(r, m) & a = mul(q, m) + r
        }
        is_mod(a, m)(r)
    } else {
        is_mod(a, m)(a)
    }
}

define mod(a: Nat, m: Nat) -> Nat: find(is_mod(a, m))

theorem mod_is_mod(a: Nat, m: Nat): is_mod(a, m)(mod(a, m)) by {
    let f: Nat -> Bool = is_mod(a, m)
    if m = 0 {
        is_mod(a, m)(a)
        is_mod(a, m)(mod(a, m))
    } else {
        lt(0, m)
        exists(q: Nat, r: Nat) { lt(r, m) & mul(q, m) + r = a }
        is_mod(a, m)(r)
        f(r)
        f(find(f))
        f(mod(a, m))
        is_mod(a, m)(mod(a, m))
    }
}

theorem add_mod(a: Nat, m: Nat): exists(q: Nat) { mul(q, m) + mod(a, m) = a } by {
    if m = 0 {
        mod(a, 0) = a
        mul(0, 0) = 0
        mul(0, 0) + mod(a, 0) = a
        exists(q: Nat) { mul(q, m) + mod(a, m) = a }
    } else {
        exists(q: Nat) { mul(q, m) + mod(a, m) = a }
    }
}

theorem mod_by_zero(a: Nat): mod(a, 0) = a

theorem mod_of_zero(m: Nat): mod(0, m) = 0

theorem mod_lte(a: Nat, m: Nat): lte(mod(a, m), a)

theorem div_sub_mod(a: Nat, m: Nat): divides(m, sub(a, mod(a, m))) by {
    exists(q: Nat) { mul(q, m) + mod(a, m) = a }
    sub(a, mod(a, m)) = mul(q, m)
    divides(m, mul(q, m))
}

theorem sub_left_distrib(a: Nat, b: Nat, c: Nat):
    mul(a, sub(b, c)) = sub(mul(a, b), mul(a, c)) by {
    if a = 0 {
        mul(a, sub(b, c)) = sub(mul(a, b), mul(a, c))
        sub_left_distrib(a, b, c)
    } else {
        if lt(b, c) {
            lt(mul(a, b), mul(a, c))
            sub(mul(a, b), mul(a, c)) = 0
            sub(b, c) = 0
            mul(a, sub(b, c)) = sub(mul(a, b), mul(a, c))
            sub_left_distrib(a, b, c)
        }
        if !lt(b, c) {
            sub(b, c) + c = b
            mul(a, sub(b, c) + c) = mul(a, sub(b, c)) + mul(a, c)
            mul(a, b) = mul(a, sub(b, c)) + mul(a, c)
            mul(a, sub(b, c)) = sub(mul(a, b), mul(a, c))
            sub_left_distrib(a, b, c)
        }
        sub_left_distrib(a, b, c)
    }
    sub_left_distrib(a, b, c)
}

theorem sub_right_distrib(a: Nat, b: Nat, c: Nat):
    mul(sub(a, b), c) = sub(mul(a, c), mul(b, c)) by {
    mul(sub(a, b), c) = mul(c, sub(a, b))
    mul(sub(a, b), c) = sub(mul(c, a), mul(c, b))
    mul(sub(a, b), c) = sub(mul(a, c), mul(c, b))
    sub(mul(a, c), mul(c, b)) = sub(mul(a, c), mul(b, c))
}

theorem divides_sub(a: Nat, b: Nat, d: Nat):
    divides(d, a) & divides(d, b) -> divides(d, sub(a, b)) by {
    exists(qa: Nat) { mul(qa, d) = a }
    exists(qb: Nat) { mul(qb, d) = b }
    sub(a, b) = sub(mul(qa, d), mul(qb, d))
    sub(a, b) = mul(sub(qa, qb), d)
    divides(d, mul(sub(qa, qb), d))
    divides(d, sub(a, b))
}

theorem divides_mod(a: Nat, m: Nat, d: Nat):
    divides(d, a) & divides(d, m) -> divides(d, mod(a, m)) by {
    exists(q: Nat) { mul(q, m) + mod(a, m) = a }
    mod(a, m) = sub(a, mul(q, m))
    divides(d, mul(q, m))
    divides(d, sub(a, mul(q, m)))
    divides(d, mod(a, m))
}

theorem div_imp_mod(a: Nat, m: Nat): divides(m, a) -> mod(a, m) = 0 by {
    if m != 0 {
        divides(m, m)
        divides(m, mod(a, m))
        lt(mod(a, m), m)
        !lte(m, mod(a, m))
        mod(a, m) = 0
    } else {
        a = 0
        mod(a, m) = 0
    }
    mod(a, m) = 0
}

theorem small_mod(a: Nat, m: Nat): lt(a, m) -> mod(a, m) = a by {
    exists(q: Nat) { mul(q, m) + mod(a, m) = a }
    if q = 0 {
        0 + mod(a, m) = a
        mod(a, m) = a
    } else {
        m != 0
        mul(q, m) != 0
        divides(m, mul(q, m))
        lte(m, mul(q, m))
        lte(m, a)
        false
    }
    mod(a, m) = a
}

theorem mod_mod(a: Nat, m: Nat): mod(mod(a, m), m) = mod(a, m) by {
    if m != 0 {
        lt(mod(a, m), m)
        mod(mod(a, m), m) = mod(a, m)
        mod_mod(a, m)
    } else {
        mod(mod(a, m), m) = mod(a, m)
        mod_mod(a, m)
    }
}

theorem mod_mul(m: Nat, q: Nat): mod(mul(q, m), m) = 0 by {
    divides(m, mul(q, m))
}

theorem divides_add_copy(a: Nat, b: Nat, d: Nat):
    divides(d, a) & divides(d, b) -> divides(d, a + b)

theorem divides_unmod(d: Nat, a: Nat, m: Nat):
    divides(d, m) & divides(d, mod(a, m)) -> divides(d, a) by {
    exists(q: Nat) { mul(q, m) + mod(a, m) = a }
    divides(m, mul(q, m))
    divides(d, mul(q, m))
    divides(d, mul(q, m) + mod(a, m))
    divides(d, a)
    if !divides_unmod(d, a, m) {
        divides(d, m)
        divides(d, mod(a, m))
        false
    }
}